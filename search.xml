<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Codeforces Global Round 1 (CF1110) （未完结，只有 A-F）]]></title>
    <url>%2F2019%2F02%2F15%2FCodeforces-Global-Round-1-CF1110-%EF%BC%88%E6%9C%AA%E5%AE%8C%E7%BB%93%EF%BC%8C%E5%8F%AA%E6%9C%89-A-F%EF%BC%89%2F</url>
    <content type="text"><![CDATA[继续补题。因为看见同学打了这场，而且涨分还不错，所以觉得这套题目可能会比较有意思。 因为下午要开学了，所以恐怕暂时不能把这套题目补完了，所以先把 A-F 放上来。 A. Parity保存 %2 的值就可以了。 12345678910const int N = 1e5 + 7;int b, k, a[N], ans;int main() &#123; read(b), read(k); for (int i = 1; i &lt;= k; ++i) read(a[i]); for (int i = k, p = 1; i; --i, p = p * b % 2) (ans += a[i] * p) %= 2; if (ans) puts("odd"); else puts("even");&#125; B. Tape一开始准备二分，然后发现他要的是最小的总长度，不太好二分。然后发现我们在断的时候，应该尽量把间隙比较大的优先断掉，所以直接贪心，排个序就可以了。 123456789101112const int N = 1e5 + 7;int n, m, k, a[N], b[N], c[N], ans;int main()&#123; read(n), read(m), read(k); for (int i = 1; i &lt;= n; ++i) read(a[i]), b[i - 1] = a[i] - a[i - 1], c[i] = i; std::sort(c + 1, c + n, [](const int &amp;x, const int &amp;y)&#123;return b[x] &gt; b[y];&#125;); std::sort(c + 1, c + k); c[k] = n; for (int i = 1; i &lt;= k; ++i) ans += a[c[i]] - a[c[i - 1] + 1] + 1; printf("%d\n", ans);&#125; C. Meaningless Operations好一道打表题。 想得百无聊赖之下开始打表，然后就有惊喜了。 发现除了 $2^k-1$ 外的数，答案都是比他大的最小的 $2^k-1$ 。 那么 $2^k-1$ 自己呢？一开始没有把表打全，以为就是如果 $k$ 是偶数，就是 $a/3$ ，否则就是 $1$ ，结果交上去 wa2. 于是继续打 $2^k-1$，其实这个时候可以直接把所有的表直接复制上去。可我偏要找出规律来。好像答案都是原数的因数，而且——而且似乎还是最大的因数啊。 于是就可以 A 掉了。 f(a) = \max_{0 < b < a}{gcd(a \oplus b, a \> \& \> b)}.仔细想一下，对于这个式子，如果 $a \neq 2^k-1$ ，那么 $a$ 就不是所有位都为 $1$ ，那么令 $b = ~a$ ，那么 $a \oplus b = 2 ^ k - 1, a > \&amp; > b = 0$ 。于是 $gcd$ 就是 $2^k-1$。 否则呢，如果 $a$ 的二进制位全是 $1$ ，那么这里的 $b$ 应该是 $0$ ，显然不满足要求。发现当 $a$ 二进制位都是 $1$ 时， $a \oplus b = a - b$， $a > \&amp; > b = b$ 。于是原式可化为 $f(a) = \max \limits_{0 &lt; b &lt; a}{gcd(a - b, b)} = \max \limits_{0 &lt; b &lt; a}{gcd(a, b)}$ 。显然当 $b | a$ 时 $f(a)$ 最大，于是 $b$ 就是 $a$ 最大的因数。 1234567891011121314151617181920212223int q, x;inline int Get(int x) &#123; int ans = 0; while (x) ++ans, x &gt;&gt;= 1; return ans;&#125;inline int Get2(int x) &#123; if (x == 1) return 0; for (int i = 2, p = sqrt(x); i &lt;= p; ++i) if(x % i == 0) return x / i; return 1;&#125;int main() &#123; read(q); for (int i = 1; i &lt;= q; ++i) &#123; read(x); int p = Get(x), s = (1 &lt;&lt; p) - 1; if (s != x) printf("%d\n", s); else printf("%d\n", Get2(s)); &#125;&#125; D. Jongmah我感觉这道题比 E,F 都难。可能是因为太菜了才会这样想。（因为目前这六道题里面只有这道题是看题解做的。。。） 首先最重要的结论是 $(i, i + 1, i + 2)$ 这样的顺子最多取两个，否则可以自己先把对子 $(i , i, i)$取完是不会比原方案差的。 于是我们限制一下顺子取的个数就可以了。 设 $dp[i][j][k]$ 表示 dp 到第 $i$ 个数，保证对子 $(i - 1, i, i + 1)$ 取 $j$ 个，对子 $(i, i + 1, i + 2)$ 取 $k$ 个。 那么有 dp[i][j][k] = \max_{l = 0} ^ 2 {dp[i][l][j] + k + \lfloor \frac{num[i] - j - k - l}3 \rfloor}1234567891011121314151617const int N = 1e6 + 7;int n, m, x, a[N], dp[N][3][3];int main() &#123; #ifdef hzhkk freopen("hkk.in", "r", stdin); #endif read(n); read(m); for (int i = 1; i &lt;= n; ++i) read(x), ++a[x]; for (int i = 1; i &lt;= m; ++i) for (int j = 0; j &lt;= 2; ++j) for (int k = 0; k &lt;= 2; ++k) for (int l = 0; l &lt;= 2; ++l) if(a[i] &gt;= j + k + l) SMAX(dp[i][j][k], dp[i - 1][l][j] + k + (a[i] - j - k - l) / 3); printf("%d\n", dp[m][0][0]);&#125; E. Magic Stones一开始捣鼓了半天推出了一堆奇怪的没有用的性质。于是后来干脆直接划掉重新换个思路思考。 记得好像对于序列上进行变化的题目好多都是用差分来做的，所以我开始从差分上考虑。 然后发现好像差分完就没了。 c_i' = c_{i + 1} + c_{i - 1} - c_i\\ \text{可以推得}\\ c_{i + 1} - c_i' = c_i - c_{i - 1}\\ c_i' - c_{i - 1} = c_{i + 1} - c_i也就是说一次操作其实是把差分数组上两个数交换一下。 注意要特判一下两端的原数据，因为两端不可以进行操作。一开始没有注意，就wa4了一次。 12345678910111213141516171819const int N = 1e5 + 7;int n, m, c[N], t[N];int main() &#123; #ifdef hzhkk freopen("hkk.in", "r", stdin); #endif read(n); for (int i = 1; i &lt;= n; ++i) read(c[i]); for (int i = 1; i &lt;= n; ++i) read(t[i]); if (c[1] != t[1] || c[n] != t[n]) return puts("No"); for (int i = n; i &gt; 1; --i) c[i] = c[i] - c[i - 1]; for (int i = n; i &gt; 1; --i) t[i] = t[i] - t[i - 1]; std::sort(c + 2, c + n + 1); std::sort(t + 2, t + n + 1); if (!memcmp(c + 2, t + 2, sizeof(int) * (n - 1))) puts("Yes"); else puts("No");&#125; F. Nearest Leaf映象中这道题好像是我们学校学长暑假讲过的原题，但是记不起来了，去翻 ppt 却很神奇地没有找到。 但是不影响这道题确实不难。 显然是离线，把询问挂在 $v$ 上，假设 $dis[i]$ 表示 $v$ 到 $i$ 的距离，可以发现，从父亲跳到儿子，会把儿子的子树内的点的 $dis$ 值加上 $w$ ( $w$ 是边权)，其余的点减上 $w$ 。 直接线段树维护即可。 注意代码里面的 $dis$ 数组和上面的分析里面的 $dis$ 不是一个东西。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768using std::min;#define lc o &lt;&lt; 1#define rc o &lt;&lt; 1 | 1const int N = 5e5 + 7;const ll INF = 0x3f3f3f3f3f3f3f3f;int n, m, x, y, z, dfc, fa[N], dfn[N], num[N], w[N];ll dis[N], ans[N];struct Edge &#123;int to, ne, w;&#125; g[N &lt;&lt; 1]; int head[N], tot;inline void Addedge(int x, int y, int z) &#123;g[++tot].to = y; g[tot].w = z; g[tot].ne = head[x]; head[x] = tot;&#125;struct Question&#123;int l, r; ll *ans;&#125;;std::vector&lt;Question&gt; q[N];struct Node&#123;ll val, add;&#125; t[N &lt;&lt; 2];inline void Build(int o, int L, int R) &#123; if (L == R) return (void)(t[o].val = dis[L]); int M = L + R &gt;&gt; 1; Build(lc, L, M); Build(rc, M + 1, R); t[o].val = min(t[lc].val, t[rc].val);&#125;inline void Add(int o, int L, int R, int l, int r, ll k) &#123; // dbg("o = %d, L = %d, R = %d, l = %d, r = %d, k = %d\n", o, L, R, l, r, k); if (l &lt;= L &amp;&amp; R &lt;= r) return (void)(t[o].add += k, t[o].val += k); int M = L + R &gt;&gt; 1; if (l &lt;= M) Add(lc, L, M, l, r, k); if (r &gt; M) Add(rc, M + 1, R, l, r, k); t[o].val = min(t[lc].val, t[rc].val) + t[o].add;&#125;inline ll Qmin(int o, int L, int R, int l, int r) &#123; if (l &lt;= L &amp;&amp; R &lt;= r) return t[o].val; int M = L + R &gt;&gt; 1; if (r &lt;= M) return Qmin(lc, L, M, l, r) + t[o].add; if (l &gt; M) return Qmin(rc, M + 1, R, l, r) + t[o].add; return min(Qmin(lc, L, M, l, r), Qmin(rc, M + 1, R, l, r)) + t[o].add;&#125;inline void dfs_pre(int x) &#123; num[x] = 1; for fec(i, x, y) dfs_pre(y), num[x] += num[y];&#125;inline void dfs(int x) &#123; if(x &gt; 1) &#123; Add(1, 1, n, 1, n, w[x]); Add(1, 1, n, x, x + num[x] - 1, -w[x] &lt;&lt; 1); &#125; for (auto i : q[x]) *i.ans = Qmin(1, 1, n, i.l, i.r); for fec(i, x, y) dfs(y); if(x &gt; 1) &#123; Add(1, 1, n, 1, n, -w[x]); Add(1, 1, n, x, x + num[x] - 1, w[x] &lt;&lt; 1); &#125;&#125;int main() &#123; #ifdef hzhkk freopen("hkk.in", "r", stdin); #endif read(n), read(m); for (int i = 2; i &lt;= n; ++i) read(y), read(z), dis[i] = dis[y] + z, Addedge(fa[i] = y, i, w[i] = z); for (int i = 2; i &lt;= n; ++i) dis[fa[i]] = INF; for (int i = 1; i &lt;= m; ++i) read(x), read(y), read(z), q[x].pb((Question)&#123;y, z, ans + i&#125;); Build(1, 1, n); dfs_pre(1); dfs(1); for (int i = 1; i &lt;= m; ++i) printf("%I64d\n", ans[i]);&#125;]]></content>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AtCoder] NIKKEI Programming Contest 2019 (暂缺F)]]></title>
    <url>%2F2019%2F02%2F13%2FAtCoder-NIKKEI-Programming-Contest-2019-%E6%9A%82%E7%BC%BAF%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;本来看见这一场的排名的画风比较正常就来补一下题，但是完全没有发现后两题的AC人数远少于我补的上一份AtCoder。 A - Subscribers&emsp;&emsp;首先始终 $max = \min(A, B)$ ，$min$ 的话如果 $A + B \leq N$ ，那么就是 $0$ ，否则就是 $A + B - N$ 。 1234567int n, a, b;int main() &#123; read(n), read(a), read(b); if (a + b &lt;= n) printf("%d 0\n", std::min(a, b)); else printf("%d %d\n", std::min(a, b), a + b - n);&#125; B - Touitsu&emsp;&emsp;直接枚举每一位，看看有几个相同的就行了。 123456789101112int n, ans;char a[N], b[N], c[N];int main() &#123; scanf("%d%s%s%s", &amp;n, a + 1, b + 1, c + 1); for (int i = 1; i &lt;= n; ++i) &#123; if(a[i] == b[i] &amp;&amp; b[i] == c[i]) ; else if(a[i] != b[i] &amp;&amp; a[i] != c[i] &amp;&amp; b[i] != c[i]) ans += 2; else ++ans; &#125; printf("%d\n", ans);&#125; C - Different Strokes&emsp;&emsp;挺好一道题，就是有点简单。 &emsp;&emsp;我们考虑对于每一个人来说，假设他选的集合是 $S$ ，他要最大化这个东西： \sum_{i \in S} a[i] - \sum_{i \notin S} b[i]&emsp;&emsp;如果我们假设 $B = \sum \limits_{i = 1} ^ n b[i]$ ，那么上式可化为： (\sum_{i \in S} a[i] +b[i]) -B&emsp;&emsp;因此不管是谁，都应该尽量选择 $a[i]+b[i]$ 大的位置上的数。直接用一个堆维护一下就可了。（不过好像可以直接排一下序就可以啦，我似乎傻掉了） 123456789101112131415161718const int N = 1e5 + 7;int n, a[N], b[N];ll ans;struct cmp &#123; int operator () (const int &amp;x, const int &amp;y) const &#123; return a[x] + b[x] &lt; a[y] +b[y]; &#125;&#125;;std::priority_queue&lt;int, std::vector&lt;int&gt;, cmp&gt; q;int main() &#123; read(n); for (int i = 1; i &lt;= n; ++i) read(a[i]), read(b[i]), q.push(i); for (int i = 1; i &lt;= n; ++i) if (i &amp; 1) ans += a[q.top()], q.pop(); else ans -= b[q.top()], q.pop(); printf("%lld\n", ans);&#125; D - Restore the Tree&emsp;&emsp;怎么感觉 D 比 C 还简单啊。至少 C 还要想一会儿列个式子， 这道题好像是读完题就可以开始写了。 &emsp;&emsp;因为保证新加的边始终是从祖先连向孩子的，所以图里面的边实际上表示了深度的大小关系，因此根肯定还是入度为 0 的。找到根以后拓扑排序一下就可了，最后一个拓扑到 $i$ 的点就是 $i$ 的父亲。 1234567891011121314151617181920212223242526const int N = 1e5 + 7;int n, m, x, y, rt, idg[N], fa[N];struct Edge &#123;int to, ne;&#125; g[N]; int head[N], tot;inline void Addedge(int x, int y) &#123;g[++tot].to = y; g[tot].ne = head[x]; head[x] = tot;&#125;int q[N], hd, tl;inline void BFS() &#123; q[++tl] = rt; while (hd &lt; tl) &#123; int x = q[++hd]; for fec(i, x, y) if (!--idg[y]) fa[y] = x, q[++tl] = y; &#125;&#125;int main() &#123; #ifdef hzhkk freopen("hkk.in", "r", stdin); #endif read(n), read(m); for (int i = 1; i &lt;= n - 1 + m; ++i) read(x), read(y), Addedge(x, y), ++idg[y]; for (int i = 1; i &lt;= n; ++i) if(!idg[i]) rt = i; BFS(); for (int i = 1; i &lt;= n; ++i) printf("%d\n", fa[i]);&#125; E - Weights on Vertices and Edges&emsp;&emsp;好题啊。 &emsp;&emsp;一开始我想的是肯定要从大到小枚举边要不要删。然后可以发现不在最小生成树上的边不管怎么删都不影响原图的连通性，于是可以直接把原图变成一棵树的时候，那么可以直接上 LCT 来维护连通性以及一些信息。但是似乎方法是成立的，只是额在AtCoder上如果还要写LCT，是真的不敢想啊。 &emsp;&emsp;于是又思考了一个小时，也没什么新思路，只能去看了一下题解。 &emsp;&emsp;是这样的，我们对于删边发过来，变成从小到大加边，用并查集来维护一下每个联通块的点权和。但是我们会发现，有些边可能之前是不能加的，但是随着后续的加边，联通块扩大了，那些边就可以加入了！ &emsp;&emsp;题解提供了一种很巧妙的办法，我们对于那样的边，我们把它们的联通块先连起来，但是并查集要记录所有并没有真正加进去的边的数量，显然后面如果我们真正加边的时候，就可以把该联通块并完以后，里面没有加的边都加进去了。 123456789101112131415161718192021222324252627282930const int N = 1e5 + 7;int n, m, w[N], ans;struct Edge&#123;int x, y, z;&#125; g[N];int fa[N], num[N];ll sum[N];inline int Find(int x) &#123;return fa[x] == x ? x : fa[x] = Find(fa[x]);&#125;inline void Union(int x, int y) &#123; fa[y = Find(y)] = x = Find(x); num[x] += num[y], num[y] = 0; sum[x] += sum[y], sum[y] = 0;&#125;int main() &#123; #ifdef hzhkk freopen("hkk.in", "r", stdin); #endif read(n), read(m); for (int i = 1; i &lt;= n; ++i) read(w[i]), fa[i] = i, sum[i] = w[i]; for (int i = 1; i &lt;= m; ++i) read(g[i].x), read(g[i].y), read(g[i].z); std::sort(g + 1, g + m +1, [](const Edge &amp;a, const Edge &amp;b)&#123;return a.z &lt; b.z;&#125;); for (int i = 1; i &lt;= m; ++i) &#123; int x = Find(g[i].x), y = Find(g[i].y), z = g[i].z; if (Find(x) != Find(y)) Union(x, y); ++num[x]; if (sum[x] &gt;= z) ans += num[x], num[x] = 0; &#125; printf("%d\n", m - ans);&#125; &emsp;&emsp;后来到网上又翻了一会儿题解，发现我之前的方法还是有救的，而且还有两种解救的办法。 &emsp;&emsp;第一种是通过不带路径压缩，只用按秩合并来做的并查集，这种并查集的单次操作的时间复杂度是 $O(\log n)$ 的，而且因为没有路径压缩，可以很方便地实现 Cut 操作，比 LCT 好写，当然也就只适合这道题了，并查集扩展性没有 LCT 好。 &emsp;&emsp;第二种是建立 Kruskal 重构树。那么在从小到大枚举最小生成树里面的边的时候，对于一条边，如果其父亲没有被删除，那么显然他自己也不需要被删除了。因此如果判断的话，首先判断其父亲有没有被删，然后再看看其所在联通块的点权和——其现在所在联通块就是在重构树上的子树！这样的方法，因为删边时一定是从根山道这条边的，所以不需要更该其祖先的子树和的信息。 &emsp;&emsp;此上三中方法的时间复杂度都是 $O(m\log n)$ 。我就只写了第一种。 F - Jewels&emsp;&emsp;想了两个小时也不会做，上网找题解也找不到，看来我可能需要去研读一下官方的英文题解。但是由于我英语比较烂，所以F可能要咕。]]></content>
      <tags>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[[AtCoder] Yahoo Programming Contest 2019]]></title>
    <url>%2F2019%2F02%2F12%2FAtCoder-Yahoo-Programming-Contest-2019%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;很遗憾错过了一场 AtCoder 。听说这场是涨分场呢，于是特意来补一下题。 A - Anti-Adjacency&emsp;&emsp;显然 $K \leq \frac{N + 1}2$ 12345678910int n, k;int main() &#123; #ifdef hzhkk freopen("hkk.in", "r", stdin); #endif read(n), read(k); if (k &lt;= (n + 1 &gt;&gt; 1)) puts("YES"); else puts("NO");&#125; B - Path&emsp;&emsp;欧拉路。 123456789101112const int N = 7;int n = 4, x, y, deg[N], jcnt;int main() &#123; #ifdef hzhkk freopen("hkk.in", "r", stdin); #endif for (int i = 1; i &lt; n; ++i) read(x), read(y), ++deg[x], ++deg[y]; for (int i = 1; i &lt;= n; ++i) if(deg[i] &amp; 1) ++jcnt; if (jcnt == 0 ||jcnt == 2) puts("YES"); else puts("NO");&#125; C - When I hit my pocket…&emsp;&emsp;如果 $B-A\leq 2$的话，那么直接拍饼干肯定不比做交易差。 &emsp;&emsp;否则，就先把饼干数拍到 $A$ ，然后就卖一次买一次，最后如果还有单独的一次操作机会就拍一下就可以了。 1234567891011121314151617int k, a, b;int main() &#123; #ifdef hzhkk freopen("hkk.in", "r", stdin); #endif read(k), read(a), read(b); if (b - a &lt;= 2) return printf("%d\n", k + 1), 0; if (k &lt;= a - 1) return printf("%d\n", k + 1), 0; else&#123; ll ans = 1; ans += a - 1; k -= a - 1; ans += (ll)(k &gt;&gt; 1) * (b - a); if (k &amp; 1) ++ans; printf("%lld\n", ans); &#125;&#125; D - Ears&emsp;&emsp;D题就开始比 A, B, C 有思维啦。 &emsp;&emsp;我们发现在走路的过程中可以一直重复来回走一个格子，这样可以不改变格子的值得奇偶性的情况下，任意改变上面的数。于是，我们联想到奇偶性以后，可以发现，如果我们将走偶数次视为没有走的话，可以发现，这个轨迹最后就是一条直线。也就是说，整个轨迹应该是 偶——奇——偶。 &emsp;&emsp;然后我就很天真地开始写——但是这样例死活过不去。好吧，因为如果想要某个格子走0次的话，就不满足上面的规律了——因为0次需要严格地不走。所以整个轨迹应该是 0——（偶）——（奇）——（偶）——0。其中括号里面的任何一项都可以不存在。 &emsp;&emsp;然后记录一下处在那一段，直接dp就可以了。 12345678910111213141516171819202122const int N = 2e5 + 7;const ll INF = 0x3f3f3f3f3f3f3f3f;int n, a[N];ll dp[N][5], ans = INF;int main() &#123; #ifdef hzhkk freopen("hkk.in", "r", stdin); #endif read(n); for (int i = 1; i &lt;= n; ++i) read(a[i]); dp[0][1] = dp[0][2] = dp[0][3] = dp[0][4] = INF; for (int i = 1; i &lt;= n; ++i) &#123; dp[i][0] = dp[i - 1][0] + a[i]; dp[i][1] = std::min(dp[i - 1][0], dp[i - 1][1]) + (a[i] ? (a[i] &amp; 1) : 2); dp[i][2] = std::min(std::min(dp[i - 1][1], dp[i - 1][2]), dp[i - 1][0]) + (a[i] &amp; 1 ^ 1); dp[i][3] = std::min(dp[i - 1][2], dp[i - 1][3]) + (a[i] ? (a[i] &amp; 1) : 2); dp[i][4] = std::min(std::min(dp[i - 1][1], dp[i - 1][2]), std::min(dp[i - 1][3], dp[i - 1][4])) + a[i]; &#125; for (int i = 0; i &lt; 5; ++i) SMIN(ans, dp[n][i]); printf("%lld\n", ans);&#125; E - Odd Subrectangles&emsp;&emsp;我个人感觉这道题是这一场里面最难的，比F还要难。我一开始想dp，但是发现好像不太行。然后想了半天想不出来，只能看了一眼题解的前几句话。直接把那两句话复制过来吧。 &emsp;&emsp;”如果选的行数确定了，那么选某一列的奇偶性也会确定。“主要get到假设选的行先确定的思路。 &emsp;&emsp;然后继续推，那么想要让选的列加起来的奇偶性为偶数，那么只能选奇数个和是奇数列，和是偶数的随便选多少。 &emsp;&emsp;那么我们假设有 $a$ 个偶数列， $b$ 个奇数列。那么就是选的列的方案数就是 $且是奇数2^a \cdot \sum \limits_{i\leq b\text{且}i是奇数}{C_b^{i}} = 2^a \cdot 2^{b-1} = 2^{m-1}$。所以不管怎么选行，对应的列的方案数总是 $2^{m-1}$ ——但是，$b$ 如果是 $0$ 的话，那么没办法选奇数个奇数列了！那么也就是说，如果我们把一行看做一个数，那么我们选的这些行的异或和不应该为 $0$！ ​ 那么异或和不为 $0$ 的方案数就是线性基的套路了。证明可以自己百度，也很简单，这里给出结论：如果线性基的大小是$r$ ，原序列的长度为 $n$，那么异或和不为 $0$ 的方案数为 $2^n - 2^{n-r}$。 12345678910111213141516171819202122232425262728const int N = 300 + 7;const int P = 998244353;int n, m, a[N][N], b[N][N], r;inline int fpow(int x, int y) &#123; int ans = 1; for (; y; y &gt;&gt;= 1, x = (ll)x * x % P) if (y &amp; 1) ans = (ll)ans * x % P; return ans;&#125;int main() &#123; #ifdef hzhkk freopen("hkk.in", "r", stdin); #endif read(n), read(m); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) read(a[i][j]); for (int i = 1; i &lt;= n; ++i)&#123; for (int j = 1; j &lt;= m; ++j) if (a[i][j]) if (!b[j][j]) &#123; for (int k = 1; k &lt;= m; ++k) b[j][k] = a[i][k]; ++r; break; &#125; else for (int k = 1; k &lt;= m; ++k) a[i][k] ^= b[j][k]; &#125; printf("%lld\n", (ll)fpow(2, m - 1) * (fpow(2, n) + P - fpow(2, n - r)) % P);&#125; F - Pass&emsp;&emsp;对于问序列的方案数的题目的套路，一般是考虑直接构造序列，考虑这个序列需要满足的特征。 &emsp;&emsp;发现对于序列的前 $i$ 项（$1 \leq i \leq n$ 也就是说不包括后 $n$ 项），他能拿到的球一定只能来自前 $i$ 个人。这样的话，红球和蓝球的数量都有了上限，也同时因为对方的上限也有了下限。 &emsp;&emsp;这样的话就是 dp 的裸题了。设 $dp[i][j]$ 表示前 $i$ 步，拿了 $j$ 个蓝球的方案数，讨论这一部拿红球还是蓝球转移一下就好了。 12345678910111213141516171819202122232425const int N = 2000 + 7;const int P = 998244353;int n, cntb[N &lt;&lt; 1], dp[N &lt;&lt; 1][N &lt;&lt; 1];char s[N];inline void Inc(int &amp;x, int y) &#123;x += y; x &gt;= P ? x -= P : 0;&#125;int main() &#123; #ifdef hzhkk freopen("hkk.in", "r", stdin); #endif scanf("%s", s + 1); n = strlen(s + 1); for (int i = 1; i &lt;= n; ++i) cntb[i] = cntb[i - 1] + s[i] - '0'; for (int i = n + 1; i &lt;= (n &lt;&lt; 1); ++i) cntb[i] = cntb[i - 1]; dp[0][0] = 1; for (int i = 1; i &lt;= (n &lt;&lt; 1); ++i) &#123; for (int j = std::max(cntb[i] - i, 0); j &lt;= std::min(cntb[i], i); ++j) &#123; if (j) dp[i][j] = dp[i - 1][j - 1]; if (i &gt; j) Inc(dp[i][j], dp[i - 1][j]); // dbg("dp[%d][%d] = %d\n", i, j, dp[i][j]); &#125; &#125; printf("%d\n", dp[n &lt;&lt; 1][cntb[n]]);&#125;]]></content>
      <tags>
        <tag>AtCoder</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Codeforces Round #538 (Div. 2)(CF1114)]]></title>
    <url>%2F2019%2F02%2F11%2FCodeforces-Round538-(Div.%202)-(CF1114)%2F</url>
    <content type="text"><![CDATA[&emsp;&emsp;今天昨天晚上的cf打的非常惨（仅代表淮中最低水平 &emsp;&emsp;先是一路缓慢地才A掉B,C，然后就开始杠D。于是写出了一个O(n^2)的线性dp，然后就wa6，调到结束。结束后发现完全看漏了两句话。噢，起始点！！！ &emsp;&emsp;好吧然后算算自己有可能这一场要变成+0，反正在0左右。结束后开始然后开始写D，顺便思考F。结果写完D发现A怎么fst了，然后。。。因为习惯于对相似的语句复制粘贴，有些东西没有改——三句话都在 -a！！！（这个还能过pt？ &emsp;&emsp;好吧想完F以后又顺便看了一下。发现怎么B也fst了？？？发现好像忘了考虑相同的数的问题。。。 &emsp;&emsp;还好C没有fst。所以大概不多不少，可以把上一场涨的分数给抵掉。 &emsp;&emsp;也是wph学长说的好，这些都是用血换来的教训啊。（但是看错题真的不应该，这是在NOIP就犯过的错啊。 A. Got Any Grapes?&emsp;&emsp;这种题目直接做，显然是先尽量供给Andrew，然后是Dmitry，最后是Michal。 &emsp;&emsp;希望大家不要犯我犯过的错误。（以后记得复制粘贴相似内容的时候注意修改全所有该修改的东西啊） 1234567891011121314int x, y, z, a, b, c;inline void End() &#123;puts("NO"); exit(0);&#125;int main() &#123; read(a), read(b), read(c); read(x), read(y), read(z); if (x &lt; a) End(); else x -= a; y += x; if (y &lt; b) End(); else y -= b; z += y; if (z &lt; c) End(); else z -= c; puts("YES");&#125; B. Yet Another Array Partitioning Task&emsp;&emsp;CF上的B题一般都是大胆猜结论题目。 &emsp;&emsp;直接猜结论： 一定可以选齐前 $m \cdot k$ 大的数。然后分的时候只要凑齐 $m$ 个在前 $m \cdot k$ 大的数中的数，就可以切一块。 &emsp;&emsp;注意一下（也是我fst的原因），如果前 $m \cdot k$ 中最小的数没有被选全的话，那么分的时候要注意判断一下那个数已经选了多少个，不够选了就不要把它算上去。 1234567891011121314151617const int N = 2e5 + 7;int n, m, k, p, a[N], b[N];ll ans;std::map&lt;int, int&gt; mp;int main() &#123; read(n), read(m), read(k); p = m * k; --k; for (int i = 1; i &lt;= n; ++i) read(a[i]), b[i] = a[i]; std::sort(b + 1, b + n + 1); for (int i = n - p + 1; i &lt;= n; ++i) ans += b[i], mp[b[i]]++; printf("%I64d\n", ans); for (int i = 1, cnt = 0; i &lt;= n; ++i) &#123; if (mp.count(a[i]) &amp;&amp; mp[a[i]]) ++cnt, --mp[a[i]]; if (cnt == m) --k, printf("%d%c", i, " \n"[k == 0]), cnt = 0; if (!k) return 0; &#125;&#125; C. Trailing Loves (or L’oeufs?)&emsp;&emsp;在 $b$ 进制下末尾有 $k$ 个0，那么说明 \quad b ^ k | n!&emsp;&emsp;于是我们把 $b$ 分解质因数 (p_1^{k_1} \cdot p_2^{k_2} \cdot \cdots) ^k | n!&emsp;&emsp;于是我们发现 k = \min\{\log_{p_1} n!,\ \log_{p_2}{n!},\ \cdots\ \}&emsp;&emsp;至于说 $\log_p{n!}$ 怎么求，这个应该是普及组知识了。 \log_p n!= \sum_{i = 1} \lfloor \frac n {p ^ i} \rfloor12345678910111213141516171819202122232425262728293031const int N = 1e6 + 7;ll n, m, ans = 0x7fffffffffffffff;int np[N], p[N], prt, cnt[N];inline void Make_Prime(int n )&#123; np[0] = np[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; if (!np[i]) p[++prt] = i; for (int j = 1; j &lt;= prt &amp;&amp; i * p[j] &lt;= n; ++j) &#123; np[i * p[j]] = 1; if (i % p[j]) break; &#125; &#125;&#125;inline ll GetNum(ll n, ll x) &#123; ll ans = 0; while (n) ans += n /= x; return ans;&#125;int main() &#123; read(n), read(m); Make_Prime(sqrt(m)); ll hkk = m; for (int i = 1; i &lt;= prt; ++i) while (hkk % p[i] == 0) hkk /= p[i], ++cnt[i]; for (int i = 1; i &lt;= prt; ++i) if (cnt[i]) SMIN(ans, GetNum(n, p[i]) / cnt[i]); if (hkk &gt; 1) SMIN(ans, GetNum(n, hkk)); printf("%I64d\n", ans);&#125; D. Flood Fill&emsp;&emsp;这道题一开始没看见起始方块这个东西，一直wa6。 &emsp;&emsp;如果有起始点，那就是区间dp模板了。 &emsp;&emsp;设 $dp[i][j]$ 表示 $i..j$ 的这段区间全部化成一种颜色的代价。 dp[i][j] = \left\{ \begin{align*} &dp[i+1][j-1] &&c[i] = c[j]\\ &\min\{dp[i][j-1], dp[i][j+1]\} + 1 &&c[i] \neq c[j] \end{align*} \right.123456789101112131415const int N = 5000 + 7;const int INF = 0x3f3f3f3f;int n, m, c[N], dp[N][N];int main() &#123; read(n); for (int i = 1; i &lt;= n; ++i) read(c[i]), SMAX(m, c[i]); n = std::unique(c + 1, c + n +1) - c - 1; for (int i = n; i; --i) for (int j = i + 1; j &lt;= n; ++j) if(c[i] == c[j]) dp[i][j] = dp[i + 1][j - 1] + 1; else dp[i][j] = std::min(dp[i][j - 1], dp[i + 1][j]) + 1; printf("%d\n", dp[1][n]);&#125; E. Arithmetic Progression&emsp;&emsp;交互题娱乐身心。 &emsp;&emsp;显然我们一个二分就可以很开心地求出最大值。 &emsp;&emsp;然后我们就可发现，任意两个数的差都应该是公差的倍数。于是我们多随机一些位置，因为前面二分过，所以后面最多问30次左右（当然不能直接问前30个，防止毒瘤会卡），把位置上的值与最大值的差算出来，那么公差一定是它们的约数，有很大的概率是 $\gcd$ 。 &emsp;&emsp;不会证明正确率。 12345678910111213141516171819202122232425const int N = 1e6 + 7;int n, L, R, stp, used[N];int main() &#123; read(n); srand(time(0)); int l = 0, r = 1e9; while (l &lt; r) &#123; int mid = (l + r) &gt;&gt; 1, get; printf("&gt; %d\n", mid); fflush(stdout); read(get); if(get) l = mid + 1; else r = mid; &#125; R = l; for (int i = 1, get = 0; i &lt;= 30 &amp;&amp; i &lt;= n; ++i) &#123; int pos = rand() % n + 1; while(used[pos]) pos = rand() % n + 1; used[pos] = 1; printf("? %d\n", pos); fflush(stdout); read(get); stp = std::__gcd(stp, R - get); &#125; printf("! %d %d\n", R - (n - 1) * stp, stp); fflush(stdout);&#125; F. Please, another Queries on Array?&emsp;&emsp;回顾一下欧拉函数的公式。 \varphi(n) = n \sum_{p\text{是}n\text{质因数}} 1-\frac1p&emsp;&emsp;所以我们只需要线段树维护区间乘积，以及每个质数出没出现过。 &emsp;&emsp;一开始打算用bitset，但是发现 $300$ 以内质数只有 $62$ 个，不多不少，可以直接 ull存。大概 ll也就够了。 &emsp;&emsp;注意区间乘积，乘标记在区间上算贡献要以幂的形式算上去，而不是像求区间和那样直接乘。一开始没注意到，死活过不去。还有如果是用 ull压位的，注意算集合的时候 1 &lt;&lt; i要写成1ull &lt;&lt; i。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#define lc o &lt;&lt; 1#define rc o &lt;&lt; 1 | 1typedef std::pair&lt;ull, int&gt; pli;const int N = 4e5 + 7;const int M = 300 + 7;const int P = 1e9 + 7;int n, m, x, y, z, a[N];char opt[15];int prt, p[M], np[M], inv[N], id[N];inline void Make_Prime(int n) &#123; np[0] = np[1] = inv[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; inv[i] = (ll)(P - P / i) * inv[P % i] % P; if (!np[i]) p[++prt] = i, id[i] = prt; for (int j = 1; j &lt;= prt &amp;&amp; i * p[j] &lt;= n; ++j)&#123; np[i * p[j]] = j; if (i % p[j] == 0) break; &#125; &#125;&#125;inline pli operator + (const pli &amp;a, const pli &amp;b) &#123;return pli(a.fi | b.fi, (ll)a.se * b.se % P);&#125;inline int fpow(int x, int y) &#123; int ans = 1; for (; y; y &gt;&gt;= 1, x= (ll)x * x % P) if(y &amp; 1) ans = (ll)ans * x % P; return ans;&#125;struct Node &#123; ull val, add; int mul, tag;&#125; t[N &lt;&lt; 2];inline void Build(int o, int L, int R) &#123; t[o].tag = 1; if (L == R) &#123; int x = a[L]; t[o].mul = a[L]; while (x &gt; 1 &amp;&amp; np[x]) t[o].val |= 1ull &lt;&lt; (np[x] - 1), x /= p[np[x]]; if (x &gt; 1) t[o].val |= 1ull &lt;&lt; (id[x] - 1); return; &#125; int M = (L + R) &gt;&gt; 1; Build(lc, L, M); Build(rc, M + 1, R); t[o].val = t[lc].val | t[rc].val; t[o].mul = (ll)t[lc].mul * t[rc].mul % P;&#125;inline void Mul(int o, int L, int R, int l, int r, int x, ull y) &#123; if (l &lt;= L &amp;&amp; R &lt;= r) &#123; t[o].tag = (ll)t[o].tag * x % P; t[o].mul = (ll)t[o].mul * fpow(x, R - L + 1) % P; t[o].add |= y; t[o].val |= t[o].add; return; &#125; int M = (L + R) &gt;&gt; 1; if (l &lt;= M) Mul(lc, L, M, l, r, x, y); if (r &gt; M) Mul(rc, M + 1, R, l, r, x, y); t[o].val = t[lc].val | t[rc].val | t[o].add; t[o].mul = (ll)t[lc].mul * t[rc].mul % P *fpow(t[o].tag, R - L + 1) % P;&#125;inline pli Get(int o, int L, int R, int l, int r, pli add = pli(0, 1)) &#123; if (l &lt;= L &amp;&amp; R &lt;= r) return pli(t[o].val, t[o].mul) + pli(add.fi, fpow(add.se, R - L + 1)); int M = (L + R) &gt;&gt; 1; pli hkk = add + pli(t[o].add, t[o].tag); if (r &lt;= M) return Get(lc, L, M, l, r, hkk); if (l &gt; M) return Get(rc, M + 1, R, l, r, hkk); return Get(lc, L, M, l, r, hkk) + Get(rc, M + 1, R, l, r, hkk);&#125;inline int GetAns(pli x) &#123; int ans = x.se; ull S = x.fi; for (int i = 1; i &lt;= prt; ++i) if((S &gt;&gt; (i - 1)) &amp; 1) ans = (ll)ans * inv[p[i]] % P * (p[i] - 1) % P; return ans;&#125;int main() &#123; #ifdef hzhkk freopen("hkk.in", "r", stdin); #endif read(n), read(m); Make_Prime(300); for (int i = 1; i &lt;= n; ++i) read(a[i]); Build(1, 1, n); for (int i = 1; i &lt;= m; ++i) &#123; scanf("%s", opt); read(x), read(y); if (*opt == 'M') &#123; read(z); ull hkk = 0; int r = z; while (r &gt; 1 &amp;&amp; np[r]) hkk |= 1ull &lt;&lt; (np[r] - 1), r /= p[np[r]]; if (r &gt; 1) hkk |= 1ull &lt;&lt; (id[r] - 1); Mul(1, 1, n, x, y, z, hkk); &#125; else printf("%d\n", GetAns(Get(1, 1, n, x, y))); &#125;&#125;]]></content>
      <tags>
        <tag>Codeforces</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2Fbaidu_verify_zcx6HEDLuz.html</url>
    <content type="text"><![CDATA[zcx6HEDLuz]]></content>
  </entry>
  <entry>
    <title><![CDATA[404]]></title>
    <url>%2F%2F404.html</url>
    <content type="text"></content>
  </entry>
  <entry>
    <title><![CDATA[关于]]></title>
    <url>%2Fabout%2Findex.html</url>
    <content type="text"><![CDATA[一个正在奋斗的 OIer。]]></content>
  </entry>
  <entry>
    <title><![CDATA[friends]]></title>
    <url>%2Ffriends%2Findex.html</url>
    <content type="text"><![CDATA[同届 OIer Link ForwardFuture fluttersunny 倾尘 学长 Link yanQval zcysky 萧昈黎 HolyK]]></content>
  </entry>
  <entry>
    <title><![CDATA[tags]]></title>
    <url>%2Ftags%2Findex.html</url>
    <content type="text"></content>
  </entry>
</search>
