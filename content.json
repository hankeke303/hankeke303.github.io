{"meta":{"title":"hankeke","subtitle":"一面风情深有韵，半笺娇恨寄幽怀。","description":null,"author":"hankeke","url":"https://www.violetoj.com"},"pages":[{"title":"404","date":"2019-03-12T12:50:15.000Z","updated":"2019-03-18T09:19:09.005Z","comments":false,"path":"/404.html","permalink":"https://www.violetoj.com//404.html","excerpt":"","text":"你可能输错了链接。 不然的话，我很好奇啊，你是怎么点进来的？"},{"title":"friends","date":"2019-03-12T11:57:09.000Z","updated":"2019-03-12T12:31:56.690Z","comments":true,"path":"friends/index.html","permalink":"https://www.violetoj.com/friends/index.html","excerpt":"","text":"同届 OIer Link ForwardFuture fluttersunny 倾尘 学长 Link yanQval zcysky 萧昈黎 HolyK"},{"title":"关于","date":"2019-03-12T11:29:33.000Z","updated":"2019-03-18T09:21:51.091Z","comments":true,"path":"about/index.html","permalink":"https://www.violetoj.com/about/index.html","excerpt":"","text":"一个正在奋斗的 OIer。 现在就读于江苏省淮阴中学。 是一个只有梦想没有实力的 OIer。 欢迎加各路神仙来指导一下小蒟蒻，将不胜感激。 QQ 号是： 1131938614 别的可能会需要的信息在左边都有了。"},{"title":"tags","date":"2019-03-12T11:55:03.633Z","updated":"2019-03-12T11:55:03.633Z","comments":true,"path":"tags/index.html","permalink":"https://www.violetoj.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"卡常者π酱 题解","slug":"卡常者π酱-题解","date":"2019-03-14T02:14:00.000Z","updated":"2019-03-18T10:44:31.472Z","comments":true,"path":"2019/03/14/卡常者π酱-题解/","link":"","permalink":"https://www.violetoj.com/2019/03/14/卡常者π酱-题解/","excerpt":"现在终于可以公布一下这道题目的改编来源了。 http://codeforces.com/contest/1120/problem/C CF1120 C 的数据范围就是 $n \\leq 5000$ 。 大概把 CF 上原题的代码复制粘贴过来可以获得 $15-20\\ pts$。","text":"现在终于可以公布一下这道题目的改编来源了。 http://codeforces.com/contest/1120/problem/C CF1120 C 的数据范围就是 $n \\leq 5000$ 。 大概把 CF 上原题的代码复制粘贴过来可以获得 $15-20\\ pts$。 现在是吐槽环节。 以下是几个出题人的代号： 123hkk = hankekezcr = 憧憬未来 = ForwardFutureyy = isunny = fluttersunny 这是来自出题人的吐槽。 首先这道题是上个星期 CF 的题目了，本来写了一个 $O(n^2\\log n)$ 我就没有管了。 但是一个星期以后，zcr 突然想知道了我是怎么做的。于是又讨论起来了这道题。 讨论讨论着，就发现了一些单调性，一开始以为没有什么用，没有管。但是后来突然觉得，好像把我的方法通过这些单调性扩展一下，可以做到 $O(n\\log n)$ 。于是，我们联系了一下这场比赛的出题人，这道题的雏形（一开始的数据范围）就出来了。 一开始，$15\\%$ 是给的原题数据范围，这个一直都没有变。一开始是 $n \\leq 50000$ 的。 但是第二天发现了 zcr 的刷表法也可以通过单调性扩展。而且由于这种算法不需要线段树合并，虽然复杂度没有变，但是常数比较小。 随后，下午，zcr 发现这道题可以用单调队列维护，于是就出现了 $O(n)$ 的算法。于是，这道题的 $n$ 由 $500000$ 扩大成了 $5000000​$。 之所以不开 $10 ^ 6$，是因为怕常数小的树状数组或者手写二叉堆的做法卡过去。但是这样线性做法的 SAM 就会 MLE 了。于是我们把字符集缩小成了 $a-g$。这也就导致了随机数据这一项目似乎根本不存在的尴尬局面。 而且还有一个情况没有预料到的情况，就是本来按照我们最初的设想，这道题可能会用到 SAM + 线段树合并 + 单调队列优化 DP，要想到可能也要稍微花一些时间。但是随着我们后来的一步步研究，似乎越来越简单了。第二个算法先是把把线段树合并给去掉了，单调队列也不用了，变成一个线段树区间修改，而且似乎这个算法只需要在暴力的基础上稍微扩展一下就能想到，这下子就变成了了 NOIP D2T1 难度了。然后再优化，结果干脆把线段树都去掉了，变成单调队列优化 DP —— 这不是普及组内容吗？但是似乎已经不怎么来得及把这道题撤回来了，于是就变成了整场比赛最简单的题目了。 还有一个情况就是按照剧本，时间限制应该是 std 的两倍以上。可惜洛谷在有 $40​$ 个点的情况下最多只能开 $3s​$。 这里向大家道歉。 以下是题解。 $n \\leq 5000$ 以及 随机数据这个数据范围显然是 $O(n^2)$。可能会带一个 $\\log$。 我提供一个 憧憬未来 神仙在 CF 上的做法。我的做法一会儿再讲。 我们设 $dp[i]$ 表示前 $i$ 位的最小花费。我们采用刷表法来更新后续状态。 dp[i] + b \\rightarrow dp[j]\\ |\\ i < j , s_{i+1..j} \\subseteq s_{1..i}怎么判断 $s_{i + 1..j}​$ 怎么判断是不是前面 $1..i​$ 的字串呢？我们只需要对前 $i​$ 的字符建立 SAM，然后在上面跑就可以了，一直到无法继续向下走就可以了。 这样的时间复杂度是 $O(n^2)​$。但是如果数据随机的话，那么不会跑太长的串就会被断掉，所以是可以通过随机数据的。 $n \\leq 50000$我们暂时先不介绍 $n \\leq 50000$ 的做法。先来讲一下我在 CF 上的写法。 因为我对于刷表不太熟悉，所以直接考虑了怎么填表，所以方法相比于上一种略微繁琐。 我们发现问题就是判断 $j + 1$ 到 $i$ 的部分是不是 $1$ 到 $j$ 部分的字串，$i$ 是固定的。 如果能够在 parent 树上找到 $j + 1$ 到 $i$ 部分对应的点的话，那么其实就是判断这个点的 $endpos$ 集合（也叫 $right$ 集合，两种不同的叫法）里面是否有 $1$ 到 $j$ 区间内的点。这个可以用线段树合并解决。 但是现在的问题就只剩一个了。如何找到 $j + 1$ 到 $i$ 的串在 parent 树上的点。我们发现，如果把 $j$ 从 $i - 1$ 到 $0$ 倒序循环，那么就相当于每次在一个串的前面加上一个字符。这个过程实际上就是在 parent 树上向下走的过程。如果现在这个串的长度仍然小于等于当前节点的 $maxlen​$，那么就应该停留在原地。如果大于了，那么需要选择一个合适的孩子向下走。具体的选择方法可以参考这个串上的对应位置的字符。 我们可以 $O(n^2\\log n)$ 解决这个 $n \\leq 5000​$ 的问题，但是显然会被上面的吊打。 但是我们发现，肯定存在一个位置 $p​$ 使得 $\\forall j \\in [1, p]​$，$j + 1​$ 到 $i​$ 的串不是 $1​$ 到 $j​$ 的子串，而 $\\forall j \\in (p, i)​$ 都有 $j + 1​$ 到 $i​$ 的串是 $1​$ 到 $j​$ 的子串。也就是说，是否是字串这一条件是单调的。 于是我们可以二分或者倍增地求出这个 $p​$ 值，然后通过线段树查询 $(p, i)​$ 区间内的 $dp​$ 值的最小值，转移即可。 时间复杂度 $O(n \\log^2 n)$。如果常数小也许能过 $n \\leq 500000$ 吧，没有试过。一个 $\\log​$ 的 std-force 对于 $n \\leq 50000$ 都很卡常了。。。 $n \\leq 500000$其实正解与 $n \\leq 50000$ 的部分分相差不大，因为是第一次出题，所以不太会配置部分分，所有导致严重不合理。 我们发现，当 $i$ 向右移动到 $i + 1$ 的时候，$p$ 点的位置应该是非严格单调增的。证明的话可以伪证一下： 假设 $p$ 点移动到了 $p’$，那么就是说 $\\forall j \\in (p’, i + 1)$，都有 $j + 1$ 到 $i + 1$ 的串是 $1$ 到 $j$ 的子串。 又因为 $j + 1$ 到 $i$ 是 $j + 1$ 到 $i + 1$ 的字串，所以可以$\\forall j \\in (p’, i)$，都有 $j + 1$ 到 $i$ 的串 $1$ 到 $j$ 的子串。 因此 $(p’, i) \\subseteq (p, i)$ ，即 $p’ \\geq p$。 那么有了这个性质，我们可以每次更新 $i$ 的时候把 $p$ 向右移动直到能够匹配，然后单调队列或者线段树维护一下就可以了。这样就不需要每次重新算了，$p$ 的位置最多一共向右移动 $n$ 次，时间复杂度 $O(n\\log n)$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114#include&lt;bits/stdc++.h&gt;#define fec(i, x, y) (int i = head[x], y = g[i].to; i; i = g[i].ne, y = g[i].to)#define dbg(...) fprintf(stderr, __VA_ARGS__)#define File(x) freopen(#x\".in\", \"r\", stdin), freopen(#x\".out\", \"w\", stdout)#define fi first#define se second#define pb push_backtemplate&lt;typename A, typename B&gt; inline char SMAX(A &amp;a, const B &amp;b) &#123;return a &lt; b ? a = b , 1 : 0;&#125;template&lt;typename A, typename B&gt; inline char SMIN(A &amp;a, const B &amp;b) &#123;return b &lt; a ? a = b , 1 : 0;&#125;typedef long long ll; typedef unsigned long long ull; typedef std::pair&lt;int, int&gt; pii;template&lt;typename I&gt;inline void read(I &amp;x) &#123; int f = 0, c; while (!isdigit(c = getchar())) c == '-' ? f = 1 : 0; x = c &amp; 15; while (isdigit(c = getchar())) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c &amp; 15); f ? x = -x : 0;&#125;const int N = 500000 + 7;const int INF = 0x3f3f3f3f;const ll INF_ll = 0x3f3f3f3f3f3f3f3f;int n, a, b, hd, tl, tax[N], q[N &lt;&lt; 1];ll dp[N];char s[N];struct Node&#123;int c[26], len, fa;&#125; t[N &lt;&lt; 1]; int nod = 1, last = 1, edp[N &lt;&lt; 1];inline void Extend(int x, int id) &#123; int p = last, np = ++nod; t[np].len = t[p].len + 1; edp[np] = id; for (; p &amp;&amp; !t[p].c[x]; p = t[p].fa) t[p].c[x] = np; if (!p) t[np].fa = 1; else &#123; int q = t[p].c[x]; if (t[q].len == t[p].len + 1) t[np].fa = q; else &#123; int nq = ++nod; t[nq] = t[q]; t[nq].len = t[p].len + 1; t[q].fa = t[np].fa = nq; for (; p &amp;&amp; t[p].c[x] == q; p = t[p].fa) t[p].c[x] = nq; &#125; &#125; last = np;&#125;inline void Resort() &#123; for (int i = 1; i &lt;= nod; ++i) ++tax[t[i].len]; for (int i = 1; i &lt;= n; ++i) tax[i] += tax[i - 1]; for (int i = 1; i &lt;= nod; ++i) q[tax[t[i].len]--] = i;&#125;namespace SGT&#123; struct Seg&#123;int lc, rc, val;&#125; t[N * 40]; int nod, rt[N &lt;&lt; 1]; inline void Insert(int &amp;o, int L, int R, int x) &#123; if (!o) o = ++nod; ++t[o].val; if (L == R) return; int M = (L + R) &gt;&gt; 1; if (x &lt;= M) Insert(t[o].lc, L, M, x); else Insert(t[o].rc, M + 1, R, x); &#125; inline int Query(int o, int L, int R, int l, int r) &#123; if (l &gt; r) return 0; if (l &lt;= L &amp;&amp; R &lt;= r) return t[o].val; int M = (L + R) &gt;&gt; 1; if (r &lt;= M) return Query(t[o].lc, L, M, l, r); if (l &gt; M) return Query(t[o].rc, M + 1, R, l, r); return Query(t[o].lc, L, M, l, r) + Query(t[o].rc, M + 1, R, l, r); &#125; inline int Merge(int o, int p) &#123; if (!o || !p) return o ^ p; int np = ++nod; t[np].lc = Merge(t[o].lc, t[p].lc); t[np].rc = Merge(t[o].rc, t[p].rc); t[np].val = t[t[np].lc].val + t[t[np].rc].val; return np; &#125;&#125;using SGT::Insert;using SGT::Query;using SGT::rt;using SGT::Merge;int main() &#123; #ifdef hzhkk freopen(\"hkk.in\", \"r\", stdin); #else #ifndef ONLINE_JUDGE File(string); #endif #endif scanf(\"%d%d%d%s\", &amp;n, &amp;a, &amp;b, s + 1); for (int i = 1; i &lt;= n; ++i) Extend(s[i] - 'a', i); for (int i = 1; i &lt;= nod; ++i) if (edp[i]) Insert(rt[i], 1, n, edp[i]); Resort(); for (int i = nod; i; --i) rt[t[q[i]].fa] = Merge(rt[t[q[i]].fa], rt[q[i]]), SMAX(edp[t[q[i]].fa], edp[q[i]]); int o = 1, p = 0; hd = 1, tl = 0; for (int i = 1; i &lt;= n; ++i) &#123; dp[i] = INF_ll; o = t[o].c[s[i] - 'a']; while (1) &#123; if (i - p &lt;= t[t[o].fa].len) o = t[o].fa; if (p == i - 1) break; if (o &amp;&amp; Query(rt[o], 1, n, 1, p)) break; ++p; &#125; SMIN(dp[i], dp[i - 1] + a); if (Query(rt[o], 1, n, 1, p)) &#123; while (hd &lt;= tl &amp;&amp; q[hd] &lt; o) ++hd; SMIN(dp[i], dp[p] + b); &#125; while (hd &lt;= tl &amp;&amp; dp[i] &gt;= dp[q[tl]]) --tl; q[++tl] = i; &#125; printf(\"%lld\\n\", dp[n]);&#125; 由一个字符构成如果 $b \\leq a$，那么策略很显然。 第一个字符花费 $a​$，第二个字符花费 $b​$，第 $3-4​$ 个字符组成的字符串花费 $b​$，第 $5-9​$ 个字符组成的字符串花费 $b​$ ……像这样倍增下去即可。 但是如果 $b &gt; a​$ ，那么 $b​$ 就不是在任何情况下都是最优的了。令 $k = \\lceil\\frac ba\\rceil​$，那么就应该对于前 $k​$ 个字符每一个都花费 $a​$ 元。后面继续向上面一样每次花费 $b​$ 倍增即可。 $n \\leq 5000000$我们回过去考虑一下 ForwardFuture 神仙在 CF 上的做法。因为他是刷表法，所以只需要现在的 SAM 的状态就可以确定后续是不是字串的问题了。这是此题刷表法最大的优势。 我们之前在 $n \\leq 500000$ 里面曾经伪证了那里的 $p$ 是具有单调性的。那么我们不妨改变 $p$ 的定义，把 $p$ 在这里定义为： 对于一个固定的 $i$，位置 $p$ 满足 $\\forall j \\in (i, p]$ 有 $i + 1$ 到 $j$ 组成的串是 $1$ 到 $i$ 的字串，而 $\\forall j \\in (p, n]$ 则均不满足。 那么由相同的方法，可以伪证出这里的 $p$ 随着 $i$ 的增大，也是单调递增的。 于是，我们也可以用线段树对一个区间取 $\\min$ 的操作，依然实现 $O(n \\log n)$ 的算法。 这个操作也可以用一个优先队列来维护所有的取 $\\min$ 操作，但是复杂度依然是 $O(n \\log n)$。 但是受到这个方法的启发，我们用 $(pos, val)$ 来维护现在的所有取 $\\min$ 操作，那么如果存在 $pos_1 &lt; pos_2, val_1 &gt; val_2$ 的情况，那么 $1$ 这个取 $\\min$ 操作就完全没有用了。基于这个性质，完全可以用单调队列维护。 时间复杂度 $O(n)$。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;bits/stdc++.h&gt;#define fec(i, x, y) (int i = head[x], y = g[i].to; i; i = g[i].ne, y = g[i].to)#define dbg(...) fprintf(stderr, __VA_ARGS__)#define File(x) freopen(#x\".in\", \"r\", stdin), freopen(#x\".out\", \"w\", stdout)#define fi first#define se second#define pb push_backtemplate&lt;typename A, typename B&gt; inline char SMAX(A &amp;a, const B &amp;b) &#123;return a &lt; b ? a = b , 1 : 0;&#125;template&lt;typename A, typename B&gt; inline char SMIN(A &amp;a, const B &amp;b) &#123;return b &lt; a ? a = b , 1 : 0;&#125;typedef long long ll; typedef unsigned long long ull; typedef std::pair&lt;int, int&gt; pii;template&lt;typename I&gt;inline void read(I &amp;x) &#123; int f = 0, c; while (!isdigit(c = getchar())) c == '-' ? f = 1 : 0; x = c &amp; 15; while (isdigit(c = getchar())) x = (x &lt;&lt; 1) + (x &lt;&lt; 3) + (c &amp; 15); f ? x = -x : 0;&#125;const int N = 5000000 + 7;const int INF = 0x3f3f3f3f;const ll INF_ll = 0x3f3f3f3f3f3f3f3f;int n, a, b, hd, tl;ll dp[N];char s[N];pii q[N];struct Node&#123;int c[7], len, fa;&#125; t[N &lt;&lt; 1]; int nod = 1, last = 1;inline void Extend(int x) &#123; int p = last, np = ++nod; t[np].len = t[p].len + 1; for (; p &amp;&amp; !t[p].c[x]; p = t[p].fa) t[p].c[x] = np; if (!p) t[np].fa = 1; else &#123; int q = t[p].c[x]; if (t[q].len == t[p].len + 1) t[np].fa = q; else &#123; int nq = ++nod; t[nq] = t[q]; t[nq].len = t[p].len + 1; t[q].fa = t[np].fa = nq; for (; p &amp;&amp; t[p].c[x] == q; p = t[p].fa) t[p].c[x] = nq; &#125; &#125; last = np;&#125;int main() &#123; #ifdef hzhkk freopen(\"hkk.in\", \"r\", stdin); #endif scanf(\"%d%d%d%s\", &amp;n, &amp;a, &amp;b, s + 1); int o = 1, p = 0; hd = 1, tl = 0; for (int i = 1; i &lt;= n; ++i) &#123; Extend(s[i] - 'a'); dp[i] = dp[i - 1] + a; if (p &lt; i) p = i; while (o &gt; 1 &amp;&amp; p - i &lt;= t[t[o].fa].len) o = t[o].fa; if (!o) o = 1; for (; p &lt; n &amp;&amp; t[o].c[s[p + 1] - 'a']; ++p) o = t[o].c[s[p + 1] - 'a']; while (hd &lt;= tl &amp;&amp; q[hd].se &lt; i) ++hd; if (hd &lt;= tl) SMIN(dp[i], dp[q[hd].fi] + b); while (hd &lt;= tl &amp;&amp; dp[q[tl].fi] &gt;= dp[i]) --tl; q[++tl] = pii(i, p); &#125; printf(\"%lld\\n\", dp[n]);&#125;","categories":[{"name":"洛谷","slug":"洛谷","permalink":"https://www.violetoj.com/categories/洛谷/"}],"tags":[{"name":"后缀自动机","slug":"后缀自动机","permalink":"https://www.violetoj.com/tags/后缀自动机/"},{"name":"单调队列","slug":"单调队列","permalink":"https://www.violetoj.com/tags/单调队列/"},{"name":"线段树合并","slug":"线段树合并","permalink":"https://www.violetoj.com/tags/线段树合并/"}],"keywords":[{"name":"洛谷","slug":"洛谷","permalink":"https://www.violetoj.com/categories/洛谷/"}]},{"title":"Codeforces Global Round 1 (CF1110)（A-F）","slug":"Codeforces-Global-Round-1-CF1110-（未完结，只有-A-F）","date":"2019-02-15T02:55:00.000Z","updated":"2019-03-18T10:41:55.714Z","comments":true,"path":"2019/02/15/Codeforces-Global-Round-1-CF1110-（未完结，只有-A-F）/","link":"","permalink":"https://www.violetoj.com/2019/02/15/Codeforces-Global-Round-1-CF1110-（未完结，只有-A-F）/","excerpt":"继续补题。因为看见同学打了这场，而且涨分还不错，所以觉得这套题目可能会比较有意思。 因为下午要开学了，所以恐怕暂时不能把这套题目补完了，所以先把 A-F 放上来。","text":"继续补题。因为看见同学打了这场，而且涨分还不错，所以觉得这套题目可能会比较有意思。 因为下午要开学了，所以恐怕暂时不能把这套题目补完了，所以先把 A-F 放上来。 A. Parity保存 %2 的值就可以了。 12345678910const int N = 1e5 + 7;int b, k, a[N], ans;int main() &#123; read(b), read(k); for (int i = 1; i &lt;= k; ++i) read(a[i]); for (int i = k, p = 1; i; --i, p = p * b % 2) (ans += a[i] * p) %= 2; if (ans) puts(\"odd\"); else puts(\"even\");&#125; B. Tape一开始准备二分，然后发现他要的是最小的总长度，不太好二分。然后发现我们在断的时候，应该尽量把间隙比较大的优先断掉，所以直接贪心，排个序就可以了。 123456789101112const int N = 1e5 + 7;int n, m, k, a[N], b[N], c[N], ans;int main()&#123; read(n), read(m), read(k); for (int i = 1; i &lt;= n; ++i) read(a[i]), b[i - 1] = a[i] - a[i - 1], c[i] = i; std::sort(c + 1, c + n, [](const int &amp;x, const int &amp;y)&#123;return b[x] &gt; b[y];&#125;); std::sort(c + 1, c + k); c[k] = n; for (int i = 1; i &lt;= k; ++i) ans += a[c[i]] - a[c[i - 1] + 1] + 1; printf(\"%d\\n\", ans);&#125; C. Meaningless Operations好一道打表题。 想得百无聊赖之下开始打表，然后就有惊喜了。 发现除了 $2^k-1$ 外的数，答案都是比他大的最小的 $2^k-1$ 。 那么 $2^k-1$ 自己呢？一开始没有把表打全，以为就是如果 $k$ 是偶数，就是 $a/3$ ，否则就是 $1$ ，结果交上去 wa2. 于是继续打 $2^k-1$，其实这个时候可以直接把所有的表直接复制上去。可我偏要找出规律来。好像答案都是原数的因数，而且——而且似乎还是最大的因数啊。 于是就可以 A 掉了。 f(a) = \\max_{0 < b < a}{gcd(a \\oplus b, a \\> \\& \\> b)}.仔细想一下，对于这个式子，如果 $a \\neq 2^k-1$ ，那么 $a$ 就不是所有位都为 $1$ ，那么令 $b = ~a$ ，那么 $a \\oplus b = 2 ^ k - 1, a > \\&amp; > b = 0$ 。于是 $gcd$ 就是 $2^k-1$。 否则呢，如果 $a$ 的二进制位全是 $1$ ，那么这里的 $b$ 应该是 $0$ ，显然不满足要求。发现当 $a$ 二进制位都是 $1$ 时， $a \\oplus b = a - b$， $a > \\&amp; > b = b$ 。于是原式可化为 $f(a) = \\max \\limits_{0 &lt; b &lt; a}{gcd(a - b, b)} = \\max \\limits_{0 &lt; b &lt; a}{gcd(a, b)}$ 。显然当 $b | a$ 时 $f(a)$ 最大，于是 $b$ 就是 $a$ 最大的因数。 1234567891011121314151617181920212223int q, x;inline int Get(int x) &#123; int ans = 0; while (x) ++ans, x &gt;&gt;= 1; return ans;&#125;inline int Get2(int x) &#123; if (x == 1) return 0; for (int i = 2, p = sqrt(x); i &lt;= p; ++i) if(x % i == 0) return x / i; return 1;&#125;int main() &#123; read(q); for (int i = 1; i &lt;= q; ++i) &#123; read(x); int p = Get(x), s = (1 &lt;&lt; p) - 1; if (s != x) printf(\"%d\\n\", s); else printf(\"%d\\n\", Get2(s)); &#125;&#125; D. Jongmah我感觉这道题比 E,F 都难。可能是因为太菜了才会这样想。（因为目前这六道题里面只有这道题是看题解做的。。。） 首先最重要的结论是 $(i, i + 1, i + 2)$ 这样的顺子最多取两个，否则可以自己先把对子 $(i , i, i)$取完是不会比原方案差的。 于是我们限制一下顺子取的个数就可以了。 设 $dp[i][j][k]$ 表示 dp 到第 $i$ 个数，保证对子 $(i - 1, i, i + 1)$ 取 $j$ 个，对子 $(i, i + 1, i + 2)$ 取 $k$ 个。 那么有 dp[i][j][k] = \\max_{l = 0} ^ 2 {dp[i][l][j] + k + \\lfloor \\frac{num[i] - j - k - l}3 \\rfloor}1234567891011121314151617const int N = 1e6 + 7;int n, m, x, a[N], dp[N][3][3];int main() &#123; #ifdef hzhkk freopen(\"hkk.in\", \"r\", stdin); #endif read(n); read(m); for (int i = 1; i &lt;= n; ++i) read(x), ++a[x]; for (int i = 1; i &lt;= m; ++i) for (int j = 0; j &lt;= 2; ++j) for (int k = 0; k &lt;= 2; ++k) for (int l = 0; l &lt;= 2; ++l) if(a[i] &gt;= j + k + l) SMAX(dp[i][j][k], dp[i - 1][l][j] + k + (a[i] - j - k - l) / 3); printf(\"%d\\n\", dp[m][0][0]);&#125; E. Magic Stones一开始捣鼓了半天推出了一堆奇怪的没有用的性质。于是后来干脆直接划掉重新换个思路思考。 记得好像对于序列上进行变化的题目好多都是用差分来做的，所以我开始从差分上考虑。 然后发现好像差分完就没了。 c_i' = c_{i + 1} + c_{i - 1} - c_i\\\\ \\text{可以推得}\\\\ c_{i + 1} - c_i' = c_i - c_{i - 1}\\\\ c_i' - c_{i - 1} = c_{i + 1} - c_i也就是说一次操作其实是把差分数组上两个数交换一下。 注意要特判一下两端的原数据，因为两端不可以进行操作。一开始没有注意，就wa4了一次。 12345678910111213141516171819const int N = 1e5 + 7;int n, m, c[N], t[N];int main() &#123; #ifdef hzhkk freopen(\"hkk.in\", \"r\", stdin); #endif read(n); for (int i = 1; i &lt;= n; ++i) read(c[i]); for (int i = 1; i &lt;= n; ++i) read(t[i]); if (c[1] != t[1] || c[n] != t[n]) return puts(\"No\"); for (int i = n; i &gt; 1; --i) c[i] = c[i] - c[i - 1]; for (int i = n; i &gt; 1; --i) t[i] = t[i] - t[i - 1]; std::sort(c + 2, c + n + 1); std::sort(t + 2, t + n + 1); if (!memcmp(c + 2, t + 2, sizeof(int) * (n - 1))) puts(\"Yes\"); else puts(\"No\");&#125; F. Nearest Leaf映象中这道题好像是我们学校学长暑假讲过的原题，但是记不起来了，去翻 ppt 却很神奇地没有找到。 但是不影响这道题确实不难。 显然是离线，把询问挂在 $v$ 上，假设 $dis[i]$ 表示 $v$ 到 $i$ 的距离，可以发现，从父亲跳到儿子，会把儿子的子树内的点的 $dis$ 值加上 $w$ ( $w$ 是边权)，其余的点减上 $w$ 。 直接线段树维护即可。 注意代码里面的 $dis$ 数组和上面的分析里面的 $dis$ 不是一个东西。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768using std::min;#define lc o &lt;&lt; 1#define rc o &lt;&lt; 1 | 1const int N = 5e5 + 7;const ll INF = 0x3f3f3f3f3f3f3f3f;int n, m, x, y, z, dfc, fa[N], dfn[N], num[N], w[N];ll dis[N], ans[N];struct Edge &#123;int to, ne, w;&#125; g[N &lt;&lt; 1]; int head[N], tot;inline void Addedge(int x, int y, int z) &#123;g[++tot].to = y; g[tot].w = z; g[tot].ne = head[x]; head[x] = tot;&#125;struct Question&#123;int l, r; ll *ans;&#125;;std::vector&lt;Question&gt; q[N];struct Node&#123;ll val, add;&#125; t[N &lt;&lt; 2];inline void Build(int o, int L, int R) &#123; if (L == R) return (void)(t[o].val = dis[L]); int M = L + R &gt;&gt; 1; Build(lc, L, M); Build(rc, M + 1, R); t[o].val = min(t[lc].val, t[rc].val);&#125;inline void Add(int o, int L, int R, int l, int r, ll k) &#123; // dbg(\"o = %d, L = %d, R = %d, l = %d, r = %d, k = %d\\n\", o, L, R, l, r, k); if (l &lt;= L &amp;&amp; R &lt;= r) return (void)(t[o].add += k, t[o].val += k); int M = L + R &gt;&gt; 1; if (l &lt;= M) Add(lc, L, M, l, r, k); if (r &gt; M) Add(rc, M + 1, R, l, r, k); t[o].val = min(t[lc].val, t[rc].val) + t[o].add;&#125;inline ll Qmin(int o, int L, int R, int l, int r) &#123; if (l &lt;= L &amp;&amp; R &lt;= r) return t[o].val; int M = L + R &gt;&gt; 1; if (r &lt;= M) return Qmin(lc, L, M, l, r) + t[o].add; if (l &gt; M) return Qmin(rc, M + 1, R, l, r) + t[o].add; return min(Qmin(lc, L, M, l, r), Qmin(rc, M + 1, R, l, r)) + t[o].add;&#125;inline void dfs_pre(int x) &#123; num[x] = 1; for fec(i, x, y) dfs_pre(y), num[x] += num[y];&#125;inline void dfs(int x) &#123; if(x &gt; 1) &#123; Add(1, 1, n, 1, n, w[x]); Add(1, 1, n, x, x + num[x] - 1, -w[x] &lt;&lt; 1); &#125; for (auto i : q[x]) *i.ans = Qmin(1, 1, n, i.l, i.r); for fec(i, x, y) dfs(y); if(x &gt; 1) &#123; Add(1, 1, n, 1, n, -w[x]); Add(1, 1, n, x, x + num[x] - 1, w[x] &lt;&lt; 1); &#125;&#125;int main() &#123; #ifdef hzhkk freopen(\"hkk.in\", \"r\", stdin); #endif read(n), read(m); for (int i = 2; i &lt;= n; ++i) read(y), read(z), dis[i] = dis[y] + z, Addedge(fa[i] = y, i, w[i] = z); for (int i = 2; i &lt;= n; ++i) dis[fa[i]] = INF; for (int i = 1; i &lt;= m; ++i) read(x), read(y), read(z), q[x].pb((Question)&#123;y, z, ans + i&#125;); Build(1, 1, n); dfs_pre(1); dfs(1); for (int i = 1; i &lt;= m; ++i) printf(\"%I64d\\n\", ans[i]);&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"https://www.violetoj.com/categories/Codeforces/"}],"tags":[],"keywords":[{"name":"Codeforces","slug":"Codeforces","permalink":"https://www.violetoj.com/categories/Codeforces/"}]},{"title":"[AtCoder] NIKKEI Programming Contest 2019 (暂缺F)","slug":"AtCoder-NIKKEI-Programming-Contest-2019-暂缺F","date":"2019-02-13T11:41:00.000Z","updated":"2019-03-18T10:42:10.627Z","comments":true,"path":"2019/02/13/AtCoder-NIKKEI-Programming-Contest-2019-暂缺F/","link":"","permalink":"https://www.violetoj.com/2019/02/13/AtCoder-NIKKEI-Programming-Contest-2019-暂缺F/","excerpt":"&emsp;&emsp;本来看见这一场的排名的画风比较正常就来补一下题，但是完全没有发现后两题的AC人数远少于我补的上一份AtCoder。","text":"&emsp;&emsp;本来看见这一场的排名的画风比较正常就来补一下题，但是完全没有发现后两题的AC人数远少于我补的上一份AtCoder。 A - Subscribers&emsp;&emsp;首先始终 $max = \\min(A, B)$ ，$min$ 的话如果 $A + B \\leq N$ ，那么就是 $0$ ，否则就是 $A + B - N$ 。 1234567int n, a, b;int main() &#123; read(n), read(a), read(b); if (a + b &lt;= n) printf(\"%d 0\\n\", std::min(a, b)); else printf(\"%d %d\\n\", std::min(a, b), a + b - n);&#125; B - Touitsu&emsp;&emsp;直接枚举每一位，看看有几个相同的就行了。 123456789101112int n, ans;char a[N], b[N], c[N];int main() &#123; scanf(\"%d%s%s%s\", &amp;n, a + 1, b + 1, c + 1); for (int i = 1; i &lt;= n; ++i) &#123; if(a[i] == b[i] &amp;&amp; b[i] == c[i]) ; else if(a[i] != b[i] &amp;&amp; a[i] != c[i] &amp;&amp; b[i] != c[i]) ans += 2; else ++ans; &#125; printf(\"%d\\n\", ans);&#125; C - Different Strokes&emsp;&emsp;挺好一道题，就是有点简单。 &emsp;&emsp;我们考虑对于每一个人来说，假设他选的集合是 $S$ ，他要最大化这个东西： \\sum_{i \\in S} a[i] - \\sum_{i \\notin S} b[i]&emsp;&emsp;如果我们假设 $B = \\sum \\limits_{i = 1} ^ n b[i]$ ，那么上式可化为： (\\sum_{i \\in S} a[i] +b[i]) -B&emsp;&emsp;因此不管是谁，都应该尽量选择 $a[i]+b[i]$ 大的位置上的数。直接用一个堆维护一下就可了。（不过好像可以直接排一下序就可以啦，我似乎傻掉了） 123456789101112131415161718const int N = 1e5 + 7;int n, a[N], b[N];ll ans;struct cmp &#123; int operator () (const int &amp;x, const int &amp;y) const &#123; return a[x] + b[x] &lt; a[y] +b[y]; &#125;&#125;;std::priority_queue&lt;int, std::vector&lt;int&gt;, cmp&gt; q;int main() &#123; read(n); for (int i = 1; i &lt;= n; ++i) read(a[i]), read(b[i]), q.push(i); for (int i = 1; i &lt;= n; ++i) if (i &amp; 1) ans += a[q.top()], q.pop(); else ans -= b[q.top()], q.pop(); printf(\"%lld\\n\", ans);&#125; D - Restore the Tree&emsp;&emsp;怎么感觉 D 比 C 还简单啊。至少 C 还要想一会儿列个式子， 这道题好像是读完题就可以开始写了。 &emsp;&emsp;因为保证新加的边始终是从祖先连向孩子的，所以图里面的边实际上表示了深度的大小关系，因此根肯定还是入度为 0 的。找到根以后拓扑排序一下就可了，最后一个拓扑到 $i$ 的点就是 $i$ 的父亲。 1234567891011121314151617181920212223242526const int N = 1e5 + 7;int n, m, x, y, rt, idg[N], fa[N];struct Edge &#123;int to, ne;&#125; g[N]; int head[N], tot;inline void Addedge(int x, int y) &#123;g[++tot].to = y; g[tot].ne = head[x]; head[x] = tot;&#125;int q[N], hd, tl;inline void BFS() &#123; q[++tl] = rt; while (hd &lt; tl) &#123; int x = q[++hd]; for fec(i, x, y) if (!--idg[y]) fa[y] = x, q[++tl] = y; &#125;&#125;int main() &#123; #ifdef hzhkk freopen(\"hkk.in\", \"r\", stdin); #endif read(n), read(m); for (int i = 1; i &lt;= n - 1 + m; ++i) read(x), read(y), Addedge(x, y), ++idg[y]; for (int i = 1; i &lt;= n; ++i) if(!idg[i]) rt = i; BFS(); for (int i = 1; i &lt;= n; ++i) printf(\"%d\\n\", fa[i]);&#125; E - Weights on Vertices and Edges&emsp;&emsp;好题啊。 &emsp;&emsp;一开始我想的是肯定要从大到小枚举边要不要删。然后可以发现不在最小生成树上的边不管怎么删都不影响原图的连通性，于是可以直接把原图变成一棵树的时候，那么可以直接上 LCT 来维护连通性以及一些信息。但是似乎方法是成立的，只是额在AtCoder上如果还要写LCT，是真的不敢想啊。 &emsp;&emsp;于是又思考了一个小时，也没什么新思路，只能去看了一下题解。 &emsp;&emsp;是这样的，我们对于删边发过来，变成从小到大加边，用并查集来维护一下每个联通块的点权和。但是我们会发现，有些边可能之前是不能加的，但是随着后续的加边，联通块扩大了，那些边就可以加入了！ &emsp;&emsp;题解提供了一种很巧妙的办法，我们对于那样的边，我们把它们的联通块先连起来，但是并查集要记录所有并没有真正加进去的边的数量，显然后面如果我们真正加边的时候，就可以把该联通块并完以后，里面没有加的边都加进去了。 123456789101112131415161718192021222324252627282930const int N = 1e5 + 7;int n, m, w[N], ans;struct Edge&#123;int x, y, z;&#125; g[N];int fa[N], num[N];ll sum[N];inline int Find(int x) &#123;return fa[x] == x ? x : fa[x] = Find(fa[x]);&#125;inline void Union(int x, int y) &#123; fa[y = Find(y)] = x = Find(x); num[x] += num[y], num[y] = 0; sum[x] += sum[y], sum[y] = 0;&#125;int main() &#123; #ifdef hzhkk freopen(\"hkk.in\", \"r\", stdin); #endif read(n), read(m); for (int i = 1; i &lt;= n; ++i) read(w[i]), fa[i] = i, sum[i] = w[i]; for (int i = 1; i &lt;= m; ++i) read(g[i].x), read(g[i].y), read(g[i].z); std::sort(g + 1, g + m +1, [](const Edge &amp;a, const Edge &amp;b)&#123;return a.z &lt; b.z;&#125;); for (int i = 1; i &lt;= m; ++i) &#123; int x = Find(g[i].x), y = Find(g[i].y), z = g[i].z; if (Find(x) != Find(y)) Union(x, y); ++num[x]; if (sum[x] &gt;= z) ans += num[x], num[x] = 0; &#125; printf(\"%d\\n\", m - ans);&#125; &emsp;&emsp;后来到网上又翻了一会儿题解，发现我之前的方法还是有救的，而且还有两种解救的办法。 &emsp;&emsp;第一种是通过不带路径压缩，只用按秩合并来做的并查集，这种并查集的单次操作的时间复杂度是 $O(\\log n)$ 的，而且因为没有路径压缩，可以很方便地实现 Cut 操作，比 LCT 好写，当然也就只适合这道题了，并查集扩展性没有 LCT 好。 &emsp;&emsp;第二种是建立 Kruskal 重构树。那么在从小到大枚举最小生成树里面的边的时候，对于一条边，如果其父亲没有被删除，那么显然他自己也不需要被删除了。因此如果判断的话，首先判断其父亲有没有被删，然后再看看其所在联通块的点权和——其现在所在联通块就是在重构树上的子树！这样的方法，因为删边时一定是从根山道这条边的，所以不需要更该其祖先的子树和的信息。 &emsp;&emsp;此上三中方法的时间复杂度都是 $O(m\\log n)$ 。我就只写了第一种。 F - Jewels&emsp;&emsp;想了两个小时也不会做，上网找题解也找不到，看来我可能需要去研读一下官方的英文题解。但是由于我英语比较烂，所以F可能要咕。","categories":[{"name":"AtCoder","slug":"AtCoder","permalink":"https://www.violetoj.com/categories/AtCoder/"}],"tags":[],"keywords":[{"name":"AtCoder","slug":"AtCoder","permalink":"https://www.violetoj.com/categories/AtCoder/"}]},{"title":"[AtCoder] Yahoo Programming Contest 2019","slug":"AtCoder-Yahoo-Programming-Contest-2019","date":"2019-02-12T02:31:00.000Z","updated":"2019-03-18T10:42:19.762Z","comments":true,"path":"2019/02/12/AtCoder-Yahoo-Programming-Contest-2019/","link":"","permalink":"https://www.violetoj.com/2019/02/12/AtCoder-Yahoo-Programming-Contest-2019/","excerpt":"&emsp;&emsp;很遗憾错过了一场 AtCoder 。听说这场是涨分场呢，于是特意来补一下题。","text":"&emsp;&emsp;很遗憾错过了一场 AtCoder 。听说这场是涨分场呢，于是特意来补一下题。 A - Anti-Adjacency&emsp;&emsp;显然 $K \\leq \\frac{N + 1}2$ 12345678910int n, k;int main() &#123; #ifdef hzhkk freopen(\"hkk.in\", \"r\", stdin); #endif read(n), read(k); if (k &lt;= (n + 1 &gt;&gt; 1)) puts(\"YES\"); else puts(\"NO\");&#125; B - Path&emsp;&emsp;欧拉路。 123456789101112const int N = 7;int n = 4, x, y, deg[N], jcnt;int main() &#123; #ifdef hzhkk freopen(\"hkk.in\", \"r\", stdin); #endif for (int i = 1; i &lt; n; ++i) read(x), read(y), ++deg[x], ++deg[y]; for (int i = 1; i &lt;= n; ++i) if(deg[i] &amp; 1) ++jcnt; if (jcnt == 0 ||jcnt == 2) puts(\"YES\"); else puts(\"NO\");&#125; C - When I hit my pocket…&emsp;&emsp;如果 $B-A\\leq 2$的话，那么直接拍饼干肯定不比做交易差。 &emsp;&emsp;否则，就先把饼干数拍到 $A$ ，然后就卖一次买一次，最后如果还有单独的一次操作机会就拍一下就可以了。 1234567891011121314151617int k, a, b;int main() &#123; #ifdef hzhkk freopen(\"hkk.in\", \"r\", stdin); #endif read(k), read(a), read(b); if (b - a &lt;= 2) return printf(\"%d\\n\", k + 1), 0; if (k &lt;= a - 1) return printf(\"%d\\n\", k + 1), 0; else&#123; ll ans = 1; ans += a - 1; k -= a - 1; ans += (ll)(k &gt;&gt; 1) * (b - a); if (k &amp; 1) ++ans; printf(\"%lld\\n\", ans); &#125;&#125; D - Ears&emsp;&emsp;D题就开始比 A, B, C 有思维啦。 &emsp;&emsp;我们发现在走路的过程中可以一直重复来回走一个格子，这样可以不改变格子的值得奇偶性的情况下，任意改变上面的数。于是，我们联想到奇偶性以后，可以发现，如果我们将走偶数次视为没有走的话，可以发现，这个轨迹最后就是一条直线。也就是说，整个轨迹应该是 偶——奇——偶。 &emsp;&emsp;然后我就很天真地开始写——但是这样例死活过不去。好吧，因为如果想要某个格子走0次的话，就不满足上面的规律了——因为0次需要严格地不走。所以整个轨迹应该是 0——（偶）——（奇）——（偶）——0。其中括号里面的任何一项都可以不存在。 &emsp;&emsp;然后记录一下处在那一段，直接dp就可以了。 12345678910111213141516171819202122const int N = 2e5 + 7;const ll INF = 0x3f3f3f3f3f3f3f3f;int n, a[N];ll dp[N][5], ans = INF;int main() &#123; #ifdef hzhkk freopen(\"hkk.in\", \"r\", stdin); #endif read(n); for (int i = 1; i &lt;= n; ++i) read(a[i]); dp[0][1] = dp[0][2] = dp[0][3] = dp[0][4] = INF; for (int i = 1; i &lt;= n; ++i) &#123; dp[i][0] = dp[i - 1][0] + a[i]; dp[i][1] = std::min(dp[i - 1][0], dp[i - 1][1]) + (a[i] ? (a[i] &amp; 1) : 2); dp[i][2] = std::min(std::min(dp[i - 1][1], dp[i - 1][2]), dp[i - 1][0]) + (a[i] &amp; 1 ^ 1); dp[i][3] = std::min(dp[i - 1][2], dp[i - 1][3]) + (a[i] ? (a[i] &amp; 1) : 2); dp[i][4] = std::min(std::min(dp[i - 1][1], dp[i - 1][2]), std::min(dp[i - 1][3], dp[i - 1][4])) + a[i]; &#125; for (int i = 0; i &lt; 5; ++i) SMIN(ans, dp[n][i]); printf(\"%lld\\n\", ans);&#125; E - Odd Subrectangles&emsp;&emsp;我个人感觉这道题是这一场里面最难的，比F还要难。我一开始想dp，但是发现好像不太行。然后想了半天想不出来，只能看了一眼题解的前几句话。直接把那两句话复制过来吧。 &emsp;&emsp;”如果选的行数确定了，那么选某一列的奇偶性也会确定。“主要get到假设选的行先确定的思路。 &emsp;&emsp;然后继续推，那么想要让选的列加起来的奇偶性为偶数，那么只能选奇数个和是奇数列，和是偶数的随便选多少。 &emsp;&emsp;那么我们假设有 $a$ 个偶数列， $b$ 个奇数列。那么就是选的列的方案数就是 $且是奇数2^a \\cdot \\sum \\limits_{i\\leq b\\text{且}i是奇数}{C_b^{i}} = 2^a \\cdot 2^{b-1} = 2^{m-1}$。所以不管怎么选行，对应的列的方案数总是 $2^{m-1}$ ——但是，$b$ 如果是 $0$ 的话，那么没办法选奇数个奇数列了！那么也就是说，如果我们把一行看做一个数，那么我们选的这些行的异或和不应该为 $0$！ ​ 那么异或和不为 $0$ 的方案数就是线性基的套路了。证明可以自己百度，也很简单，这里给出结论：如果线性基的大小是$r$ ，原序列的长度为 $n$，那么异或和不为 $0$ 的方案数为 $2^n - 2^{n-r}$。 12345678910111213141516171819202122232425262728const int N = 300 + 7;const int P = 998244353;int n, m, a[N][N], b[N][N], r;inline int fpow(int x, int y) &#123; int ans = 1; for (; y; y &gt;&gt;= 1, x = (ll)x * x % P) if (y &amp; 1) ans = (ll)ans * x % P; return ans;&#125;int main() &#123; #ifdef hzhkk freopen(\"hkk.in\", \"r\", stdin); #endif read(n), read(m); for (int i = 1; i &lt;= n; ++i) for (int j = 1; j &lt;= m; ++j) read(a[i][j]); for (int i = 1; i &lt;= n; ++i)&#123; for (int j = 1; j &lt;= m; ++j) if (a[i][j]) if (!b[j][j]) &#123; for (int k = 1; k &lt;= m; ++k) b[j][k] = a[i][k]; ++r; break; &#125; else for (int k = 1; k &lt;= m; ++k) a[i][k] ^= b[j][k]; &#125; printf(\"%lld\\n\", (ll)fpow(2, m - 1) * (fpow(2, n) + P - fpow(2, n - r)) % P);&#125; F - Pass&emsp;&emsp;对于问序列的方案数的题目的套路，一般是考虑直接构造序列，考虑这个序列需要满足的特征。 &emsp;&emsp;发现对于序列的前 $i$ 项（$1 \\leq i \\leq n$ 也就是说不包括后 $n$ 项），他能拿到的球一定只能来自前 $i$ 个人。这样的话，红球和蓝球的数量都有了上限，也同时因为对方的上限也有了下限。 &emsp;&emsp;这样的话就是 dp 的裸题了。设 $dp[i][j]$ 表示前 $i$ 步，拿了 $j$ 个蓝球的方案数，讨论这一部拿红球还是蓝球转移一下就好了。 12345678910111213141516171819202122232425const int N = 2000 + 7;const int P = 998244353;int n, cntb[N &lt;&lt; 1], dp[N &lt;&lt; 1][N &lt;&lt; 1];char s[N];inline void Inc(int &amp;x, int y) &#123;x += y; x &gt;= P ? x -= P : 0;&#125;int main() &#123; #ifdef hzhkk freopen(\"hkk.in\", \"r\", stdin); #endif scanf(\"%s\", s + 1); n = strlen(s + 1); for (int i = 1; i &lt;= n; ++i) cntb[i] = cntb[i - 1] + s[i] - '0'; for (int i = n + 1; i &lt;= (n &lt;&lt; 1); ++i) cntb[i] = cntb[i - 1]; dp[0][0] = 1; for (int i = 1; i &lt;= (n &lt;&lt; 1); ++i) &#123; for (int j = std::max(cntb[i] - i, 0); j &lt;= std::min(cntb[i], i); ++j) &#123; if (j) dp[i][j] = dp[i - 1][j - 1]; if (i &gt; j) Inc(dp[i][j], dp[i - 1][j]); // dbg(\"dp[%d][%d] = %d\\n\", i, j, dp[i][j]); &#125; &#125; printf(\"%d\\n\", dp[n &lt;&lt; 1][cntb[n]]);&#125;","categories":[{"name":"AtCoder","slug":"AtCoder","permalink":"https://www.violetoj.com/categories/AtCoder/"}],"tags":[],"keywords":[{"name":"AtCoder","slug":"AtCoder","permalink":"https://www.violetoj.com/categories/AtCoder/"}]},{"title":"Codeforces Round #538 (Div. 2)(CF1114)","slug":"Codeforces-Round538-(Div. 2)-(CF1114)","date":"2019-02-11T10:56:00.000Z","updated":"2019-03-18T10:42:31.202Z","comments":true,"path":"2019/02/11/Codeforces-Round538-(Div. 2)-(CF1114)/","link":"","permalink":"https://www.violetoj.com/2019/02/11/Codeforces-Round538-(Div. 2)-(CF1114)/","excerpt":"&emsp;&emsp;今天昨天晚上的cf打的非常惨（仅代表淮中最低水平 &emsp;&emsp;先是一路缓慢地才A掉B,C，然后就开始杠D。于是写出了一个O(n^2)的线性dp，然后就wa6，调到结束。结束后发现完全看漏了两句话。噢，起始点！！！ &emsp;&emsp;好吧然后算算自己有可能这一场要变成+0，反正在0左右。结束后开始然后开始写D，顺便思考F。结果写完D发现A怎么fst了，然后。。。因为习惯于对相似的语句复制粘贴，有些东西没有改——三句话都在 -a！！！（这个还能过pt？ &emsp;&emsp;好吧想完F以后又顺便看了一下。发现怎么B也fst了？？？发现好像忘了考虑相同的数的问题。。。 &emsp;&emsp;还好C没有fst。所以大概不多不少，可以把上一场涨的分数给抵掉。 &emsp;&emsp;也是wph学长说的好，这些都是用血换来的教训啊。（但是看错题真的不应该，这是在NOIP就犯过的错啊。","text":"&emsp;&emsp;今天昨天晚上的cf打的非常惨（仅代表淮中最低水平 &emsp;&emsp;先是一路缓慢地才A掉B,C，然后就开始杠D。于是写出了一个O(n^2)的线性dp，然后就wa6，调到结束。结束后发现完全看漏了两句话。噢，起始点！！！ &emsp;&emsp;好吧然后算算自己有可能这一场要变成+0，反正在0左右。结束后开始然后开始写D，顺便思考F。结果写完D发现A怎么fst了，然后。。。因为习惯于对相似的语句复制粘贴，有些东西没有改——三句话都在 -a！！！（这个还能过pt？ &emsp;&emsp;好吧想完F以后又顺便看了一下。发现怎么B也fst了？？？发现好像忘了考虑相同的数的问题。。。 &emsp;&emsp;还好C没有fst。所以大概不多不少，可以把上一场涨的分数给抵掉。 &emsp;&emsp;也是wph学长说的好，这些都是用血换来的教训啊。（但是看错题真的不应该，这是在NOIP就犯过的错啊。 A. Got Any Grapes?&emsp;&emsp;这种题目直接做，显然是先尽量供给Andrew，然后是Dmitry，最后是Michal。 &emsp;&emsp;希望大家不要犯我犯过的错误。（以后记得复制粘贴相似内容的时候注意修改全所有该修改的东西啊） 1234567891011121314int x, y, z, a, b, c;inline void End() &#123;puts(\"NO\"); exit(0);&#125;int main() &#123; read(a), read(b), read(c); read(x), read(y), read(z); if (x &lt; a) End(); else x -= a; y += x; if (y &lt; b) End(); else y -= b; z += y; if (z &lt; c) End(); else z -= c; puts(\"YES\");&#125; B. Yet Another Array Partitioning Task&emsp;&emsp;CF上的B题一般都是大胆猜结论题目。 &emsp;&emsp;直接猜结论： 一定可以选齐前 $m \\cdot k$ 大的数。然后分的时候只要凑齐 $m$ 个在前 $m \\cdot k$ 大的数中的数，就可以切一块。 &emsp;&emsp;注意一下（也是我fst的原因），如果前 $m \\cdot k$ 中最小的数没有被选全的话，那么分的时候要注意判断一下那个数已经选了多少个，不够选了就不要把它算上去。 1234567891011121314151617const int N = 2e5 + 7;int n, m, k, p, a[N], b[N];ll ans;std::map&lt;int, int&gt; mp;int main() &#123; read(n), read(m), read(k); p = m * k; --k; for (int i = 1; i &lt;= n; ++i) read(a[i]), b[i] = a[i]; std::sort(b + 1, b + n + 1); for (int i = n - p + 1; i &lt;= n; ++i) ans += b[i], mp[b[i]]++; printf(\"%I64d\\n\", ans); for (int i = 1, cnt = 0; i &lt;= n; ++i) &#123; if (mp.count(a[i]) &amp;&amp; mp[a[i]]) ++cnt, --mp[a[i]]; if (cnt == m) --k, printf(\"%d%c\", i, \" \\n\"[k == 0]), cnt = 0; if (!k) return 0; &#125;&#125; C. Trailing Loves (or L’oeufs?)&emsp;&emsp;在 $b$ 进制下末尾有 $k$ 个0，那么说明 \\quad b ^ k | n!&emsp;&emsp;于是我们把 $b$ 分解质因数 (p_1^{k_1} \\cdot p_2^{k_2} \\cdot \\cdots) ^k | n!&emsp;&emsp;于是我们发现 k = \\min\\{\\log_{p_1} n!,\\ \\log_{p_2}{n!},\\ \\cdots\\ \\}&emsp;&emsp;至于说 $\\log_p{n!}$ 怎么求，这个应该是普及组知识了。 \\log_p n!= \\sum_{i = 1} \\lfloor \\frac n {p ^ i} \\rfloor12345678910111213141516171819202122232425262728293031const int N = 1e6 + 7;ll n, m, ans = 0x7fffffffffffffff;int np[N], p[N], prt, cnt[N];inline void Make_Prime(int n )&#123; np[0] = np[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; if (!np[i]) p[++prt] = i; for (int j = 1; j &lt;= prt &amp;&amp; i * p[j] &lt;= n; ++j) &#123; np[i * p[j]] = 1; if (i % p[j]) break; &#125; &#125;&#125;inline ll GetNum(ll n, ll x) &#123; ll ans = 0; while (n) ans += n /= x; return ans;&#125;int main() &#123; read(n), read(m); Make_Prime(sqrt(m)); ll hkk = m; for (int i = 1; i &lt;= prt; ++i) while (hkk % p[i] == 0) hkk /= p[i], ++cnt[i]; for (int i = 1; i &lt;= prt; ++i) if (cnt[i]) SMIN(ans, GetNum(n, p[i]) / cnt[i]); if (hkk &gt; 1) SMIN(ans, GetNum(n, hkk)); printf(\"%I64d\\n\", ans);&#125; D. Flood Fill&emsp;&emsp;这道题一开始没看见起始方块这个东西，一直wa6。 &emsp;&emsp;如果有起始点，那就是区间dp模板了。 &emsp;&emsp;设 $dp[i][j]$ 表示 $i..j$ 的这段区间全部化成一种颜色的代价。 dp[i][j] = \\left\\{ \\begin{align*} &dp[i+1][j-1] &&c[i] = c[j]\\\\ &\\min\\{dp[i][j-1], dp[i][j+1]\\} + 1 &&c[i] \\neq c[j] \\end{align*} \\right.123456789101112131415const int N = 5000 + 7;const int INF = 0x3f3f3f3f;int n, m, c[N], dp[N][N];int main() &#123; read(n); for (int i = 1; i &lt;= n; ++i) read(c[i]), SMAX(m, c[i]); n = std::unique(c + 1, c + n +1) - c - 1; for (int i = n; i; --i) for (int j = i + 1; j &lt;= n; ++j) if(c[i] == c[j]) dp[i][j] = dp[i + 1][j - 1] + 1; else dp[i][j] = std::min(dp[i][j - 1], dp[i + 1][j]) + 1; printf(\"%d\\n\", dp[1][n]);&#125; E. Arithmetic Progression&emsp;&emsp;交互题娱乐身心。 &emsp;&emsp;显然我们一个二分就可以很开心地求出最大值。 &emsp;&emsp;然后我们就可发现，任意两个数的差都应该是公差的倍数。于是我们多随机一些位置，因为前面二分过，所以后面最多问30次左右（当然不能直接问前30个，防止毒瘤会卡），把位置上的值与最大值的差算出来，那么公差一定是它们的约数，有很大的概率是 $\\gcd$ 。 &emsp;&emsp;不会证明正确率。 12345678910111213141516171819202122232425const int N = 1e6 + 7;int n, L, R, stp, used[N];int main() &#123; read(n); srand(time(0)); int l = 0, r = 1e9; while (l &lt; r) &#123; int mid = (l + r) &gt;&gt; 1, get; printf(\"&gt; %d\\n\", mid); fflush(stdout); read(get); if(get) l = mid + 1; else r = mid; &#125; R = l; for (int i = 1, get = 0; i &lt;= 30 &amp;&amp; i &lt;= n; ++i) &#123; int pos = rand() % n + 1; while(used[pos]) pos = rand() % n + 1; used[pos] = 1; printf(\"? %d\\n\", pos); fflush(stdout); read(get); stp = std::__gcd(stp, R - get); &#125; printf(\"! %d %d\\n\", R - (n - 1) * stp, stp); fflush(stdout);&#125; F. Please, another Queries on Array?&emsp;&emsp;回顾一下欧拉函数的公式。 \\varphi(n) = n \\sum_{p\\text{是}n\\text{质因数}} 1-\\frac1p&emsp;&emsp;所以我们只需要线段树维护区间乘积，以及每个质数出没出现过。 &emsp;&emsp;一开始打算用bitset，但是发现 $300$ 以内质数只有 $62$ 个，不多不少，可以直接 ull存。大概 ll也就够了。 &emsp;&emsp;注意区间乘积，乘标记在区间上算贡献要以幂的形式算上去，而不是像求区间和那样直接乘。一开始没注意到，死活过不去。还有如果是用 ull压位的，注意算集合的时候 1 &lt;&lt; i要写成1ull &lt;&lt; i。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091#define lc o &lt;&lt; 1#define rc o &lt;&lt; 1 | 1typedef std::pair&lt;ull, int&gt; pli;const int N = 4e5 + 7;const int M = 300 + 7;const int P = 1e9 + 7;int n, m, x, y, z, a[N];char opt[15];int prt, p[M], np[M], inv[N], id[N];inline void Make_Prime(int n) &#123; np[0] = np[1] = inv[1] = 1; for (int i = 2; i &lt;= n; ++i) &#123; inv[i] = (ll)(P - P / i) * inv[P % i] % P; if (!np[i]) p[++prt] = i, id[i] = prt; for (int j = 1; j &lt;= prt &amp;&amp; i * p[j] &lt;= n; ++j)&#123; np[i * p[j]] = j; if (i % p[j] == 0) break; &#125; &#125;&#125;inline pli operator + (const pli &amp;a, const pli &amp;b) &#123;return pli(a.fi | b.fi, (ll)a.se * b.se % P);&#125;inline int fpow(int x, int y) &#123; int ans = 1; for (; y; y &gt;&gt;= 1, x= (ll)x * x % P) if(y &amp; 1) ans = (ll)ans * x % P; return ans;&#125;struct Node &#123; ull val, add; int mul, tag;&#125; t[N &lt;&lt; 2];inline void Build(int o, int L, int R) &#123; t[o].tag = 1; if (L == R) &#123; int x = a[L]; t[o].mul = a[L]; while (x &gt; 1 &amp;&amp; np[x]) t[o].val |= 1ull &lt;&lt; (np[x] - 1), x /= p[np[x]]; if (x &gt; 1) t[o].val |= 1ull &lt;&lt; (id[x] - 1); return; &#125; int M = (L + R) &gt;&gt; 1; Build(lc, L, M); Build(rc, M + 1, R); t[o].val = t[lc].val | t[rc].val; t[o].mul = (ll)t[lc].mul * t[rc].mul % P;&#125;inline void Mul(int o, int L, int R, int l, int r, int x, ull y) &#123; if (l &lt;= L &amp;&amp; R &lt;= r) &#123; t[o].tag = (ll)t[o].tag * x % P; t[o].mul = (ll)t[o].mul * fpow(x, R - L + 1) % P; t[o].add |= y; t[o].val |= t[o].add; return; &#125; int M = (L + R) &gt;&gt; 1; if (l &lt;= M) Mul(lc, L, M, l, r, x, y); if (r &gt; M) Mul(rc, M + 1, R, l, r, x, y); t[o].val = t[lc].val | t[rc].val | t[o].add; t[o].mul = (ll)t[lc].mul * t[rc].mul % P *fpow(t[o].tag, R - L + 1) % P;&#125;inline pli Get(int o, int L, int R, int l, int r, pli add = pli(0, 1)) &#123; if (l &lt;= L &amp;&amp; R &lt;= r) return pli(t[o].val, t[o].mul) + pli(add.fi, fpow(add.se, R - L + 1)); int M = (L + R) &gt;&gt; 1; pli hkk = add + pli(t[o].add, t[o].tag); if (r &lt;= M) return Get(lc, L, M, l, r, hkk); if (l &gt; M) return Get(rc, M + 1, R, l, r, hkk); return Get(lc, L, M, l, r, hkk) + Get(rc, M + 1, R, l, r, hkk);&#125;inline int GetAns(pli x) &#123; int ans = x.se; ull S = x.fi; for (int i = 1; i &lt;= prt; ++i) if((S &gt;&gt; (i - 1)) &amp; 1) ans = (ll)ans * inv[p[i]] % P * (p[i] - 1) % P; return ans;&#125;int main() &#123; #ifdef hzhkk freopen(\"hkk.in\", \"r\", stdin); #endif read(n), read(m); Make_Prime(300); for (int i = 1; i &lt;= n; ++i) read(a[i]); Build(1, 1, n); for (int i = 1; i &lt;= m; ++i) &#123; scanf(\"%s\", opt); read(x), read(y); if (*opt == 'M') &#123; read(z); ull hkk = 0; int r = z; while (r &gt; 1 &amp;&amp; np[r]) hkk |= 1ull &lt;&lt; (np[r] - 1), r /= p[np[r]]; if (r &gt; 1) hkk |= 1ull &lt;&lt; (id[r] - 1); Mul(1, 1, n, x, y, z, hkk); &#125; else printf(\"%d\\n\", GetAns(Get(1, 1, n, x, y))); &#125;&#125;","categories":[{"name":"Codeforces","slug":"Codeforces","permalink":"https://www.violetoj.com/categories/Codeforces/"}],"tags":[],"keywords":[{"name":"Codeforces","slug":"Codeforces","permalink":"https://www.violetoj.com/categories/Codeforces/"}]}]}